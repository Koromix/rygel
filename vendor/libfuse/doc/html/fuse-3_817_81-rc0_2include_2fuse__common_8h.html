<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libfuse: fuse-3.17.1-rc0/include/fuse_common.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libfuse
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d0f078c01bc3ce273c081eaac57e44d3.html">fuse-3.17.1-rc0</a></li><li class="navelem"><a class="el" href="dir_8e4bcc66b5040e6cd82b8756da72da10.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">fuse_common.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;libfuse_config.h&quot;</code><br />
<code>#include &quot;<a class="el" href="fuse-3_817_81-rc0_2include_2fuse__opt_8h_source.html">fuse_opt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fuse-3_817_81-rc0_2include_2fuse__log_8h_source.html">fuse_log.h</a>&quot;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;sys/types.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
</div>
<p><a href="fuse-3_817_81-rc0_2include_2fuse__common_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__file__info.html">fuse_file_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__loop__config.html">fuse_loop_config</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__conn__info.html">fuse_conn_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__buf.html">fuse_buf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__bufvec.html">fuse_bufvec</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlibfuse__version.html">libfuse_version</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ade38f8e8c463cd40af5bfeeebfa99486" id="r_ade38f8e8c463cd40af5bfeeebfa99486"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#ade38f8e8c463cd40af5bfeeebfa99486">FUSE_IOCTL_COMPAT</a>&#160;&#160;&#160;(1 &lt;&lt; 0)</td></tr>
<tr class="separator:ade38f8e8c463cd40af5bfeeebfa99486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcf6528f7433d511f98dca35669bdd4" id="r_aabcf6528f7433d511f98dca35669bdd4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#aabcf6528f7433d511f98dca35669bdd4">FUSE_BACKING_STACKED_UNDER</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:aabcf6528f7433d511f98dca35669bdd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a38b106b28e804f7e9ed2d89a3ddf67cb" id="r_a38b106b28e804f7e9ed2d89a3ddf67cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cb">fuse_capability</a> { <br />
&#160;&#160;<a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cbae40a9bd1626cc774cc67a46ec051faf4">FUSE_CAP_ASYNC_READ</a> = (1 &lt;&lt; 0)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba548c1df52897fbd53a4347fba554b589">FUSE_CAP_POSIX_LOCKS</a> = (1 &lt;&lt; 1)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba94a40cab648de4f14210c8c1db59d3da">FUSE_CAP_ATOMIC_O_TRUNC</a> = (1 &lt;&lt; 3)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cbaa6ffa005d8db90e63eff95b903ca071b">FUSE_CAP_EXPORT_SUPPORT</a> = (1 &lt;&lt; 4)
, <br />
&#160;&#160;<a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba7e74ae987324f9562887728fa6241274">FUSE_CAP_DONT_MASK</a> = (1 &lt;&lt; 6)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba950be44a7496f04a1f8732f5c76eeaf2">FUSE_CAP_SPLICE_WRITE</a> = (1 &lt;&lt; 7)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba487f7b41c776b9bb7db55d6faf608fa6">FUSE_CAP_SPLICE_MOVE</a> = (1 &lt;&lt; 8)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba46658ce6322ac6ade7ba96b36325885c">FUSE_CAP_SPLICE_READ</a> = (1 &lt;&lt; 9)
, <br />
&#160;&#160;<a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba9993dad7572faf1a5a47c6d4a601fd2e">FUSE_CAP_FLOCK_LOCKS</a> = (1 &lt;&lt; 10)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba2655f99141602330fc2f51b9a6943668">FUSE_CAP_IOCTL_DIR</a> = (1 &lt;&lt; 11)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba2aff0cdd70be3e8843af2518e641f8e7">FUSE_CAP_AUTO_INVAL_DATA</a> = (1 &lt;&lt; 12)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba0c85cb45b525f123fe04327ac12859a4">FUSE_CAP_READDIRPLUS</a> = (1 &lt;&lt; 13)
, <br />
&#160;&#160;<a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cbaa78e5c635dfa7ef51ba42e56b7a74126">FUSE_CAP_READDIRPLUS_AUTO</a> = (1 &lt;&lt; 14)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba1d710c0cfdffe151b73cae6c18963df3">FUSE_CAP_ASYNC_DIO</a> = (1 &lt;&lt; 15)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba1e92eb8b5558ed24c4d80603b490befb">FUSE_CAP_WRITEBACK_CACHE</a> = (1 &lt;&lt; 16)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cbaa9aca5b7d7d748684b716b5b0c94c287">FUSE_CAP_NO_OPEN_SUPPORT</a> = (1 &lt;&lt; 17)
, <br />
&#160;&#160;<a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba16089189db9911a157d5c962c79d9cdc">FUSE_CAP_PARALLEL_DIROPS</a> = (1 &lt;&lt; 18)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba0705980f3d77d8109a8190ed0c2b0302">FUSE_CAP_POSIX_ACL</a> = (1 &lt;&lt; 19)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba746188a0c4f0986eb1524e1c3f3975a3">FUSE_CAP_HANDLE_KILLPRIV</a> = (1 &lt;&lt; 20)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba680ab4c15b8d49d5740745a8ce2397df">FUSE_CAP_HANDLE_KILLPRIV_V2</a> = (1 &lt;&lt; 21)
, <br />
&#160;&#160;<a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cbae7f4f914ffdbb32cc3cad1255034334b">FUSE_CAP_CACHE_SYMLINKS</a> = (1 &lt;&lt; 23)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba0d5b426b2a8799975e4985f8b3784b78">FUSE_CAP_NO_OPENDIR_SUPPORT</a> = (1 &lt;&lt; 24)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cbae97a707d493d10d8a432b89fb636ff47">FUSE_CAP_EXPLICIT_INVAL_DATA</a> = (1 &lt;&lt; 25)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cbaa532818c594cfae1fd4a1783abb5a884">FUSE_CAP_EXPIRE_ONLY</a> = (1 &lt;&lt; 26)
, <br />
&#160;&#160;<a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cbadc39ae255540f98d929d2d78827eb41b">FUSE_CAP_SETXATTR_EXT</a> = (1 &lt;&lt; 27)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cbad45865a48b78dbb4a954096e30cdb5ba">FUSE_CAP_DIRECT_IO_ALLOW_MMAP</a> = (1 &lt;&lt; 28)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba957a0b155cec67e49d295e71fc700f32">FUSE_CAP_PASSTHROUGH</a> = (1 &lt;&lt; 29)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba1da86cdaf05b701f6aaa1b494057a9d8">FUSE_CAP_NO_EXPORT_SUPPORT</a> = (1 &lt;&lt; 30)
, <br />
&#160;&#160;<a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cba02d2e230c7a0e756c070c156e61498c6">FUSE_CAP_CURRENT_MAX</a>
<br />
 }</td></tr>
<tr class="separator:a38b106b28e804f7e9ed2d89a3ddf67cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e36b839c4dbf0439bd85b61c7213a58" id="r_a5e36b839c4dbf0439bd85b61c7213a58"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a5e36b839c4dbf0439bd85b61c7213a58">fuse_buf_flags</a> { <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a5e36b839c4dbf0439bd85b61c7213a58affd5b3b7e9cdd5f89b3126eea96e033b">FUSE_BUF_IS_FD</a> = (1 &lt;&lt; 1)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a5e36b839c4dbf0439bd85b61c7213a58ad67d5c6075febad0594f06d46d02bfa9">FUSE_BUF_FD_SEEK</a> = (1 &lt;&lt; 2)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a5e36b839c4dbf0439bd85b61c7213a58af89b4b00a2d4a06d8458b320c2cb28cf">FUSE_BUF_FD_RETRY</a> = (1 &lt;&lt; 3)
 }</td></tr>
<tr class="separator:a5e36b839c4dbf0439bd85b61c7213a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0ad71a3e8c357ebe7e87cdecbdbe18" id="r_aec0ad71a3e8c357ebe7e87cdecbdbe18"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18">fuse_buf_copy_flags</a> { <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18adcef8052c48f314d4d9f9f05a5b4f838">FUSE_BUF_NO_SPLICE</a> = (1 &lt;&lt; 1)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18a375767de945f5178e8949d284abf1f5b">FUSE_BUF_FORCE_SPLICE</a> = (1 &lt;&lt; 2)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18af239e556066a5d73b3ff542216b157b9">FUSE_BUF_SPLICE_MOVE</a> = (1 &lt;&lt; 3)
, <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18a32ec833f1eb4b5cd9283cf9d93021037">FUSE_BUF_SPLICE_NONBLOCK</a> = (1 &lt;&lt; 4)
 }</td></tr>
<tr class="separator:aec0ad71a3e8c357ebe7e87cdecbdbe18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa8c278816933611a6280b9e9611441a5" id="r_aa8c278816933611a6280b9e9611441a5"><td class="memItemLeft" align="right" valign="top">struct fuse_conn_info_opts *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#aa8c278816933611a6280b9e9611441a5">fuse_parse_conn_info_opts</a> (struct <a class="el" href="structfuse__args.html">fuse_args</a> *args)</td></tr>
<tr class="separator:aa8c278816933611a6280b9e9611441a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cf81fd313a39a171275360960b0471" id="r_a55cf81fd313a39a171275360960b0471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a55cf81fd313a39a171275360960b0471">fuse_apply_conn_info_opts</a> (struct fuse_conn_info_opts *opts, struct <a class="el" href="structfuse__conn__info.html">fuse_conn_info</a> *conn)</td></tr>
<tr class="separator:a55cf81fd313a39a171275360960b0471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1857d2209952f49a762aff39f3cd8bd" id="r_af1857d2209952f49a762aff39f3cd8bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#af1857d2209952f49a762aff39f3cd8bd">fuse_daemonize</a> (int foreground)</td></tr>
<tr class="separator:af1857d2209952f49a762aff39f3cd8bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae04b2f721003f5540c71be65396c53c8" id="r_ae04b2f721003f5540c71be65396c53c8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#ae04b2f721003f5540c71be65396c53c8">fuse_version</a> (void)</td></tr>
<tr class="separator:ae04b2f721003f5540c71be65396c53c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8962ec2b8ac91cc2cb9ef8da7c004aa" id="r_ad8962ec2b8ac91cc2cb9ef8da7c004aa"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#ad8962ec2b8ac91cc2cb9ef8da7c004aa">fuse_pkgversion</a> (void)</td></tr>
<tr class="separator:ad8962ec2b8ac91cc2cb9ef8da7c004aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf5027f8a38b2efc03858efd7fdc756a" id="r_adf5027f8a38b2efc03858efd7fdc756a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#adf5027f8a38b2efc03858efd7fdc756a">fuse_pollhandle_destroy</a> (struct fuse_pollhandle *ph)</td></tr>
<tr class="separator:adf5027f8a38b2efc03858efd7fdc756a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4327f41b2fe1ca84151b407169bd86c0" id="r_a4327f41b2fe1ca84151b407169bd86c0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a4327f41b2fe1ca84151b407169bd86c0">fuse_buf_size</a> (const struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *bufv)</td></tr>
<tr class="separator:a4327f41b2fe1ca84151b407169bd86c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ca301390fb5e85b85153abb1891a3f7" id="r_a9ca301390fb5e85b85153abb1891a3f7"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a9ca301390fb5e85b85153abb1891a3f7">fuse_buf_copy</a> (struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *dst, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *src, enum <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18">fuse_buf_copy_flags</a> flags)</td></tr>
<tr class="separator:a9ca301390fb5e85b85153abb1891a3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292dccc3c7b1799cb054efa2ba0c774b" id="r_a292dccc3c7b1799cb054efa2ba0c774b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a292dccc3c7b1799cb054efa2ba0c774b">fuse_set_signal_handlers</a> (struct fuse_session *se)</td></tr>
<tr class="separator:a292dccc3c7b1799cb054efa2ba0c774b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15830cd29289a75894e21f6a3ff573fa" id="r_a15830cd29289a75894e21f6a3ff573fa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a15830cd29289a75894e21f6a3ff573fa">fuse_set_fail_signal_handlers</a> (struct fuse_session *se)</td></tr>
<tr class="separator:a15830cd29289a75894e21f6a3ff573fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb674bbc11074c4fe520b952d6bfdd30" id="r_aeb674bbc11074c4fe520b952d6bfdd30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#aeb674bbc11074c4fe520b952d6bfdd30">fuse_remove_signal_handlers</a> (struct fuse_session *se)</td></tr>
<tr class="separator:aeb674bbc11074c4fe520b952d6bfdd30"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aabcf6528f7433d511f98dca35669bdd4" name="aabcf6528f7433d511f98dca35669bdd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcf6528f7433d511f98dca35669bdd4">&#9670;&#160;</a></span>FUSE_BACKING_STACKED_UNDER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUSE_BACKING_STACKED_UNDER&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When FUSE_CAP_PASSTHROUGH is enabled, this is the maximum allowed stacking depth of the backing files. In current kernel, the maximum allowed stack depth if FILESYSTEM_MAX_STACK_DEPTH (2), which includes the FUSE passthrough layer, so the maximum stacking depth for backing files is 1.</p>
<p>The default is FUSE_BACKING_STACKED_UNDER (0), meaning that the backing files cannot be on a stacked filesystem, but another stacked filesystem can be stacked over this FUSE passthrough filesystem.</p>
<p>Set this to FUSE_BACKING_STACKED_OVER (1) if backing files may be on a stacked filesystem, such as overlayfs or another FUSE passthrough. In this configuration, another stacked filesystem cannot be stacked over this FUSE passthrough filesystem. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h_source.html#l00682">682</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h_source.html">fuse_common.h</a>.</p>

</div>
</div>
<a id="ade38f8e8c463cd40af5bfeeebfa99486" name="ade38f8e8c463cd40af5bfeeebfa99486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade38f8e8c463cd40af5bfeeebfa99486">&#9670;&#160;</a></span>FUSE_IOCTL_COMPAT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FUSE_IOCTL_COMPAT&#160;&#160;&#160;(1 &lt;&lt; 0)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ioctl flags</p>
<p>FUSE_IOCTL_COMPAT: 32bit compat ioctl on 64bit machine FUSE_IOCTL_UNRESTRICTED: not restricted to well-formed ioctls, retry allowed FUSE_IOCTL_RETRY: retry with new iovecs FUSE_IOCTL_DIR: is a directory</p>
<p>FUSE_IOCTL_MAX_IOV: maximum of in_iovecs + out_iovecs </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h_source.html#l00537">537</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h_source.html">fuse_common.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="aec0ad71a3e8c357ebe7e87cdecbdbe18" name="aec0ad71a3e8c357ebe7e87cdecbdbe18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0ad71a3e8c357ebe7e87cdecbdbe18">&#9670;&#160;</a></span>fuse_buf_copy_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18">fuse_buf_copy_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer copy flags </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aec0ad71a3e8c357ebe7e87cdecbdbe18adcef8052c48f314d4d9f9f05a5b4f838" name="aec0ad71a3e8c357ebe7e87cdecbdbe18adcef8052c48f314d4d9f9f05a5b4f838"></a>FUSE_BUF_NO_SPLICE&#160;</td><td class="fielddoc"><p>Don't use splice(2)</p>
<p>Always fall back to using read and write instead of splice(2) to copy data from one file descriptor to another.</p>
<p>If this flag is not set, then only fall back if splice is unavailable. </p>
</td></tr>
<tr><td class="fieldname"><a id="aec0ad71a3e8c357ebe7e87cdecbdbe18a375767de945f5178e8949d284abf1f5b" name="aec0ad71a3e8c357ebe7e87cdecbdbe18a375767de945f5178e8949d284abf1f5b"></a>FUSE_BUF_FORCE_SPLICE&#160;</td><td class="fielddoc"><p>Force splice</p>
<p>Always use splice(2) to copy data from one file descriptor to another. If splice is not available, return -EINVAL. </p>
</td></tr>
<tr><td class="fieldname"><a id="aec0ad71a3e8c357ebe7e87cdecbdbe18af239e556066a5d73b3ff542216b157b9" name="aec0ad71a3e8c357ebe7e87cdecbdbe18af239e556066a5d73b3ff542216b157b9"></a>FUSE_BUF_SPLICE_MOVE&#160;</td><td class="fielddoc"><p>Try to move data with splice.</p>
<p>If splice is used, try to move pages from the source to the destination instead of copying. See documentation of SPLICE_F_MOVE in splice(2) man page. </p>
</td></tr>
<tr><td class="fieldname"><a id="aec0ad71a3e8c357ebe7e87cdecbdbe18a32ec833f1eb4b5cd9283cf9d93021037" name="aec0ad71a3e8c357ebe7e87cdecbdbe18a32ec833f1eb4b5cd9283cf9d93021037"></a>FUSE_BUF_SPLICE_NONBLOCK&#160;</td><td class="fielddoc"><p>Don't block on the pipe when copying data with splice</p>
<p>Makes the operations on the pipe non-blocking (if the pipe is full or empty). See SPLICE_F_NONBLOCK in the splice(2) man page. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h_source.html#l00848">848</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h_source.html">fuse_common.h</a>.</p>

</div>
</div>
<a id="a5e36b839c4dbf0439bd85b61c7213a58" name="a5e36b839c4dbf0439bd85b61c7213a58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e36b839c4dbf0439bd85b61c7213a58">&#9670;&#160;</a></span>fuse_buf_flags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a5e36b839c4dbf0439bd85b61c7213a58">fuse_buf_flags</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Buffer flags </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5e36b839c4dbf0439bd85b61c7213a58affd5b3b7e9cdd5f89b3126eea96e033b" name="a5e36b839c4dbf0439bd85b61c7213a58affd5b3b7e9cdd5f89b3126eea96e033b"></a>FUSE_BUF_IS_FD&#160;</td><td class="fielddoc"><p>Buffer contains a file descriptor</p>
<p>If this flag is set, the .fd field is valid, otherwise the .mem fields is valid. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e36b839c4dbf0439bd85b61c7213a58ad67d5c6075febad0594f06d46d02bfa9" name="a5e36b839c4dbf0439bd85b61c7213a58ad67d5c6075febad0594f06d46d02bfa9"></a>FUSE_BUF_FD_SEEK&#160;</td><td class="fielddoc"><p>Seek on the file descriptor</p>
<p>If this flag is set then the .pos field is valid and is used to seek to the given offset before performing operation on file descriptor. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5e36b839c4dbf0439bd85b61c7213a58af89b4b00a2d4a06d8458b320c2cb28cf" name="a5e36b839c4dbf0439bd85b61c7213a58af89b4b00a2d4a06d8458b320c2cb28cf"></a>FUSE_BUF_FD_RETRY&#160;</td><td class="fielddoc"><p>Retry operation on file descriptor</p>
<p>If this flag is set then retry operation on file descriptor until .size bytes have been copied or an error or EOF is detected. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h_source.html#l00817">817</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h_source.html">fuse_common.h</a>.</p>

</div>
</div>
<a id="a38b106b28e804f7e9ed2d89a3ddf67cb" name="a38b106b28e804f7e9ed2d89a3ddf67cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38b106b28e804f7e9ed2d89a3ddf67cb">&#9670;&#160;</a></span>fuse_capability</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a38b106b28e804f7e9ed2d89a3ddf67cb">fuse_capability</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cbae40a9bd1626cc774cc67a46ec051faf4" name="a38b106b28e804f7e9ed2d89a3ddf67cbae40a9bd1626cc774cc67a46ec051faf4"></a>FUSE_CAP_ASYNC_READ&#160;</td><td class="fielddoc"><p>Indicates that the filesystem supports asynchronous read requests.</p>
<p>If this capability is not requested/available, the kernel will ensure that there is at most one pending read request per file-handle at any time, and will attempt to order read requests by increasing offset.</p>
<p>This feature is enabled by default when supported by the kernel. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba548c1df52897fbd53a4347fba554b589" name="a38b106b28e804f7e9ed2d89a3ddf67cba548c1df52897fbd53a4347fba554b589"></a>FUSE_CAP_POSIX_LOCKS&#160;</td><td class="fielddoc"><p>Indicates that the filesystem supports "remote" locking.</p>
<p>This feature is enabled by default when supported by the kernel, and if getlk() and setlk() handlers are implemented. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba94a40cab648de4f14210c8c1db59d3da" name="a38b106b28e804f7e9ed2d89a3ddf67cba94a40cab648de4f14210c8c1db59d3da"></a>FUSE_CAP_ATOMIC_O_TRUNC&#160;</td><td class="fielddoc"><p>Indicates that the filesystem supports the O_TRUNC open flag. If disabled, and an application specifies O_TRUNC, fuse first calls truncate() and then open() with O_TRUNC filtered out.</p>
<p>This feature is enabled by default when supported by the kernel. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cbaa6ffa005d8db90e63eff95b903ca071b" name="a38b106b28e804f7e9ed2d89a3ddf67cbaa6ffa005d8db90e63eff95b903ca071b"></a>FUSE_CAP_EXPORT_SUPPORT&#160;</td><td class="fielddoc"><p>Indicates that the filesystem supports lookups of "." and "..".</p>
<p>When this flag is set, the filesystem must be prepared to receive requests for invalid inodes (i.e., for which a FORGET request was received or which have been used in a previous instance of the filesystem daemon) and must not reuse node-ids (even when setting generation numbers).</p>
<p>This feature is disabled by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba7e74ae987324f9562887728fa6241274" name="a38b106b28e804f7e9ed2d89a3ddf67cba7e74ae987324f9562887728fa6241274"></a>FUSE_CAP_DONT_MASK&#160;</td><td class="fielddoc"><p>Indicates that the kernel should not apply the umask to the file mode on create operations.</p>
<p>This feature is disabled by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba950be44a7496f04a1f8732f5c76eeaf2" name="a38b106b28e804f7e9ed2d89a3ddf67cba950be44a7496f04a1f8732f5c76eeaf2"></a>FUSE_CAP_SPLICE_WRITE&#160;</td><td class="fielddoc"><p>Indicates that libfuse should try to use splice() when writing to the fuse device. This may improve performance.</p>
<p>This feature is disabled by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba487f7b41c776b9bb7db55d6faf608fa6" name="a38b106b28e804f7e9ed2d89a3ddf67cba487f7b41c776b9bb7db55d6faf608fa6"></a>FUSE_CAP_SPLICE_MOVE&#160;</td><td class="fielddoc"><p>Indicates that libfuse should try to move pages instead of copying when writing to / reading from the fuse device. This may improve performance.</p>
<p>This feature is disabled by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba46658ce6322ac6ade7ba96b36325885c" name="a38b106b28e804f7e9ed2d89a3ddf67cba46658ce6322ac6ade7ba96b36325885c"></a>FUSE_CAP_SPLICE_READ&#160;</td><td class="fielddoc"><p>Indicates that libfuse should try to use splice() when reading from the fuse device. This may improve performance.</p>
<p>This feature is enabled by default when supported by the kernel and if the filesystem implements a write_buf() handler. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba9993dad7572faf1a5a47c6d4a601fd2e" name="a38b106b28e804f7e9ed2d89a3ddf67cba9993dad7572faf1a5a47c6d4a601fd2e"></a>FUSE_CAP_FLOCK_LOCKS&#160;</td><td class="fielddoc"><p>If set, the calls to flock(2) will be emulated using POSIX locks and must then be handled by the filesystem's setlock() handler.</p>
<p>If not set, flock(2) calls will be handled by the FUSE kernel module internally (so any access that does not go through the kernel cannot be taken into account).</p>
<p>This feature is enabled by default when supported by the kernel and if the filesystem implements a flock() handler. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba2655f99141602330fc2f51b9a6943668" name="a38b106b28e804f7e9ed2d89a3ddf67cba2655f99141602330fc2f51b9a6943668"></a>FUSE_CAP_IOCTL_DIR&#160;</td><td class="fielddoc"><p>Indicates that the filesystem supports ioctl's on directories.</p>
<p>This feature is enabled by default when supported by the kernel. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba2aff0cdd70be3e8843af2518e641f8e7" name="a38b106b28e804f7e9ed2d89a3ddf67cba2aff0cdd70be3e8843af2518e641f8e7"></a>FUSE_CAP_AUTO_INVAL_DATA&#160;</td><td class="fielddoc"><p>Traditionally, while a file is open the FUSE kernel module only asks the filesystem for an update of the file's attributes when a client attempts to read beyond EOF. This is unsuitable for e.g. network filesystems, where the file contents may change without the kernel knowing about it.</p>
<p>If this flag is set, FUSE will check the validity of the attributes on every read. If the attributes are no longer valid (i.e., if the <em>attr_timeout</em> passed to <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__lowlevel_8h.html#ad28378dc569019c32acdb4995d70be18">fuse_reply_attr()</a> or set in <code>struct <a class="el" href="structfuse__entry__param.html">fuse_entry_param</a></code> has passed), it will first issue a <code>getattr</code> request. If the new mtime differs from the previous value, any cached file <em>contents</em> will be invalidated as well.</p>
<p>This flag should always be set when available. If all file changes go through the kernel, <em>attr_timeout</em> should be set to a very large number to avoid unnecessary getattr() calls.</p>
<p>This feature is enabled by default when supported by the kernel. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba0c85cb45b525f123fe04327ac12859a4" name="a38b106b28e804f7e9ed2d89a3ddf67cba0c85cb45b525f123fe04327ac12859a4"></a>FUSE_CAP_READDIRPLUS&#160;</td><td class="fielddoc"><p>Indicates that the filesystem supports readdirplus.</p>
<p>This feature is enabled by default when supported by the kernel and if the filesystem implements a readdirplus() handler. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cbaa78e5c635dfa7ef51ba42e56b7a74126" name="a38b106b28e804f7e9ed2d89a3ddf67cbaa78e5c635dfa7ef51ba42e56b7a74126"></a>FUSE_CAP_READDIRPLUS_AUTO&#160;</td><td class="fielddoc"><p>Indicates that the filesystem supports adaptive readdirplus.</p>
<p>If FUSE_CAP_READDIRPLUS is not set, this flag has no effect.</p>
<p>If FUSE_CAP_READDIRPLUS is set and this flag is not set, the kernel will always issue readdirplus() requests to retrieve directory contents.</p>
<p>If FUSE_CAP_READDIRPLUS is set and this flag is set, the kernel will issue both readdir() and readdirplus() requests, depending on how much information is expected to be required.</p>
<p>As of Linux 4.20, the algorithm is as follows: when userspace starts to read directory entries, issue a READDIRPLUS request to the filesystem. If any entry attributes have been looked up by the time userspace requests the next batch of entries continue with READDIRPLUS, otherwise switch to plain READDIR. This will reasult in eg plain "ls" triggering READDIRPLUS first then READDIR after that because it doesn't do lookups. "ls -l" should result in all READDIRPLUS, except if dentries are already cached.</p>
<p>This feature is enabled by default when supported by the kernel and if the filesystem implements both a readdirplus() and a readdir() handler. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba1d710c0cfdffe151b73cae6c18963df3" name="a38b106b28e804f7e9ed2d89a3ddf67cba1d710c0cfdffe151b73cae6c18963df3"></a>FUSE_CAP_ASYNC_DIO&#160;</td><td class="fielddoc"><p>Indicates that the filesystem supports asynchronous direct I/O submission.</p>
<p>If this capability is not requested/available, the kernel will ensure that there is at most one pending read and one pending write request per direct I/O file-handle at any time.</p>
<p>This feature is enabled by default when supported by the kernel. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba1e92eb8b5558ed24c4d80603b490befb" name="a38b106b28e804f7e9ed2d89a3ddf67cba1e92eb8b5558ed24c4d80603b490befb"></a>FUSE_CAP_WRITEBACK_CACHE&#160;</td><td class="fielddoc"><p>Indicates that writeback caching should be enabled. This means that individual write request may be buffered and merged in the kernel before they are send to the filesystem.</p>
<p>This feature is disabled by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cbaa9aca5b7d7d748684b716b5b0c94c287" name="a38b106b28e804f7e9ed2d89a3ddf67cbaa9aca5b7d7d748684b716b5b0c94c287"></a>FUSE_CAP_NO_OPEN_SUPPORT&#160;</td><td class="fielddoc"><p>Indicates support for zero-message opens. If this flag is set in the <code>capable</code> field of the <code><a class="el" href="structfuse__conn__info.html">fuse_conn_info</a></code> structure, then the filesystem may return <code>ENOSYS</code> from the open() handler to indicate success. Further attempts to open files will be handled in the kernel. (If this flag is not set, returning ENOSYS will be treated as an error and signaled to the caller).</p>
<p>Setting this flag in the <code>want</code> field enables this behavior automatically within libfuse for low level API users. If non-low level users wish to have this behavior you must return <code>ENOSYS</code> from the open() handler on supporting kernels. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba16089189db9911a157d5c962c79d9cdc" name="a38b106b28e804f7e9ed2d89a3ddf67cba16089189db9911a157d5c962c79d9cdc"></a>FUSE_CAP_PARALLEL_DIROPS&#160;</td><td class="fielddoc"><p>Indicates support for parallel directory operations. If this flag is unset, the FUSE kernel module will ensure that lookup() and readdir() requests are never issued concurrently for the same directory. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba0705980f3d77d8109a8190ed0c2b0302" name="a38b106b28e804f7e9ed2d89a3ddf67cba0705980f3d77d8109a8190ed0c2b0302"></a>FUSE_CAP_POSIX_ACL&#160;</td><td class="fielddoc"><p>Indicates support for POSIX ACLs.</p>
<p>If this feature is enabled, the kernel will cache and have responsibility for enforcing ACLs. ACL will be stored as xattrs and passed to userspace, which is responsible for updating the ACLs in the filesystem, keeping the file mode in sync with the ACL, and ensuring inheritance of default ACLs when new filesystem nodes are created. Note that this requires that the file system is able to parse and interpret the xattr representation of ACLs.</p>
<p>Enabling this feature implicitly turns on the <code>default_permissions</code> mount option (even if it was not passed to mount(2)).</p>
<p>This feature is disabled by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba746188a0c4f0986eb1524e1c3f3975a3" name="a38b106b28e804f7e9ed2d89a3ddf67cba746188a0c4f0986eb1524e1c3f3975a3"></a>FUSE_CAP_HANDLE_KILLPRIV&#160;</td><td class="fielddoc"><p>Indicates that the filesystem is responsible for unsetting setuid and setgid bits when a file is written, truncated, or its owner is changed.</p>
<p>This feature is disabled by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba680ab4c15b8d49d5740745a8ce2397df" name="a38b106b28e804f7e9ed2d89a3ddf67cba680ab4c15b8d49d5740745a8ce2397df"></a>FUSE_CAP_HANDLE_KILLPRIV_V2&#160;</td><td class="fielddoc"><p>Indicates that the filesystem is responsible for unsetting setuid and setgid bit and additionally cap (stored as xattr) when a file is written, truncated, or its owner is changed. Upon write/truncate suid/sgid is only killed if caller does not have CAP_FSETID. Additionally upon write/truncate sgid is killed only if file has group execute permission. (Same as Linux VFS behavior). KILLPRIV_V2 requires handling of</p><ul>
<li>FUSE_OPEN_KILL_SUIDGID (set in struct fuse_create_in::open_flags)</li>
<li>FATTR_KILL_SUIDGID (set in struct fuse_setattr_in::valid)</li>
<li>FUSE_WRITE_KILL_SUIDGID (set in struct fuse_write_in::write_flags)</li>
</ul>
<p>This feature is disabled by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cbae7f4f914ffdbb32cc3cad1255034334b" name="a38b106b28e804f7e9ed2d89a3ddf67cbae7f4f914ffdbb32cc3cad1255034334b"></a>FUSE_CAP_CACHE_SYMLINKS&#160;</td><td class="fielddoc"><p>Indicates that the kernel supports caching symlinks in its page cache.</p>
<p>When this feature is enabled, symlink targets are saved in the page cache. You can invalidate a cached link by calling: <code>fuse_lowlevel_notify_inval_inode(se, ino, 0, 0);</code></p>
<p>This feature is disabled by default. If the kernel supports it (&gt;= 4.20), you can enable this feature by setting this flag in the <code>want</code> field of the <code><a class="el" href="structfuse__conn__info.html">fuse_conn_info</a></code> structure. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba0d5b426b2a8799975e4985f8b3784b78" name="a38b106b28e804f7e9ed2d89a3ddf67cba0d5b426b2a8799975e4985f8b3784b78"></a>FUSE_CAP_NO_OPENDIR_SUPPORT&#160;</td><td class="fielddoc"><p>Indicates support for zero-message opendirs. If this flag is set in the <code>capable</code> field of the <code><a class="el" href="structfuse__conn__info.html">fuse_conn_info</a></code> structure, then the filesystem may return <code>ENOSYS</code> from the opendir() handler to indicate success. Further opendir and releasedir messages will be handled in the kernel. (If this flag is not set, returning ENOSYS will be treated as an error and signalled to the caller.)</p>
<p>Setting this flag in the <code>want</code> field enables this behavior automatically within libfuse for low level API users. If non-low level users with to have this behavior you must return <code>ENOSYS</code> from the opendir() handler on supporting kernels. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cbae97a707d493d10d8a432b89fb636ff47" name="a38b106b28e804f7e9ed2d89a3ddf67cbae97a707d493d10d8a432b89fb636ff47"></a>FUSE_CAP_EXPLICIT_INVAL_DATA&#160;</td><td class="fielddoc"><p>Indicates support for invalidating cached pages only on explicit request.</p>
<p>If this flag is set in the <code>capable</code> field of the <code><a class="el" href="structfuse__conn__info.html">fuse_conn_info</a></code> structure, then the FUSE kernel module supports invalidating cached pages only on explicit request by the filesystem through <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__lowlevel_8h.html#a9cb974af9745294ff446d11cba2422f1">fuse_lowlevel_notify_inval_inode()</a> or <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h.html#a56c1dfbdfaf10818dbc6c2ca6264f19a">fuse_invalidate_path()</a>.</p>
<p>By setting this flag in the <code>want</code> field of the <code><a class="el" href="structfuse__conn__info.html">fuse_conn_info</a></code> structure, the filesystem is responsible for invalidating cached pages through explicit requests to the kernel.</p>
<p>Note that setting this flag does not prevent the cached pages from being flushed by OS itself and/or through user actions.</p>
<p>Note that if both FUSE_CAP_EXPLICIT_INVAL_DATA and FUSE_CAP_AUTO_INVAL_DATA are set in the <code>capable</code> field of the <code><a class="el" href="structfuse__conn__info.html">fuse_conn_info</a></code> structure then FUSE_CAP_AUTO_INVAL_DATA takes precedence.</p>
<p>This feature is disabled by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cbaa532818c594cfae1fd4a1783abb5a884" name="a38b106b28e804f7e9ed2d89a3ddf67cbaa532818c594cfae1fd4a1783abb5a884"></a>FUSE_CAP_EXPIRE_ONLY&#160;</td><td class="fielddoc"><p>Indicates support that dentries can be expired.</p>
<p>Expiring dentries, instead of invalidating them, makes a difference for overmounted dentries, where plain invalidation would detach all submounts before dropping the dentry from the cache. If only expiry is set on the dentry, then any overmounts are left alone and until -&gt;d_revalidate() is called.</p>
<p>Note: -&gt;d_revalidate() is not called for the case of following a submount, so invalidation will only be triggered for the non-overmounted case. The dentry could also be mounted in a different mount instance, in which case any submounts will still be detached. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cbadc39ae255540f98d929d2d78827eb41b" name="a38b106b28e804f7e9ed2d89a3ddf67cbadc39ae255540f98d929d2d78827eb41b"></a>FUSE_CAP_SETXATTR_EXT&#160;</td><td class="fielddoc"><p>Indicates that an extended 'struct fuse_setxattr' is used by the kernel side - extra_flags are passed, which are used (as of now by acl) processing. For example FUSE_SETXATTR_ACL_KILL_SGID might be set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cbad45865a48b78dbb4a954096e30cdb5ba" name="a38b106b28e804f7e9ed2d89a3ddf67cbad45865a48b78dbb4a954096e30cdb5ba"></a>FUSE_CAP_DIRECT_IO_ALLOW_MMAP&#160;</td><td class="fielddoc"><p>Files opened with FUSE_DIRECT_IO do not support MAP_SHARED mmap. This restriction is relaxed through FUSE_CAP_DIRECT_IO_RELAX (kernel flag: FUSE_DIRECT_IO_RELAX). MAP_SHARED is disabled by default for FUSE_DIRECT_IO, as this flag can be used to ensure coherency between mount points (or network clients) and with kernel page cache as enforced by mmap that cannot be guaranteed anymore. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba957a0b155cec67e49d295e71fc700f32" name="a38b106b28e804f7e9ed2d89a3ddf67cba957a0b155cec67e49d295e71fc700f32"></a>FUSE_CAP_PASSTHROUGH&#160;</td><td class="fielddoc"><p>Indicates support for passthrough mode access for read/write operations.</p>
<p>If this flag is set in the <code>capable</code> field of the <code><a class="el" href="structfuse__conn__info.html">fuse_conn_info</a></code> structure, then the FUSE kernel module supports redirecting read/write operations to the backing file instead of letting them to be handled by the FUSE daemon.</p>
<p>This feature is disabled by default. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba1da86cdaf05b701f6aaa1b494057a9d8" name="a38b106b28e804f7e9ed2d89a3ddf67cba1da86cdaf05b701f6aaa1b494057a9d8"></a>FUSE_CAP_NO_EXPORT_SUPPORT&#160;</td><td class="fielddoc"><p>Indicates that the file system cannot handle NFS export</p>
<p>If this flag is set NFS export and name_to_handle_at is not going to work at all and will fail with EOPNOTSUPP. </p>
</td></tr>
<tr><td class="fieldname"><a id="a38b106b28e804f7e9ed2d89a3ddf67cba02d2e230c7a0e756c070c156e61498c6" name="a38b106b28e804f7e9ed2d89a3ddf67cba02d2e230c7a0e756c070c156e61498c6"></a>FUSE_CAP_CURRENT_MAX&#160;</td><td class="fielddoc"><p>Current maximum capability value. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h_source.html#l00177">177</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h_source.html">fuse_common.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a55cf81fd313a39a171275360960b0471" name="a55cf81fd313a39a171275360960b0471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cf81fd313a39a171275360960b0471">&#9670;&#160;</a></span>fuse_apply_conn_info_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_apply_conn_info_opts </td>
          <td>(</td>
          <td class="paramtype">struct fuse_conn_info_opts *&#160;</td>
          <td class="paramname"><em>opts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfuse__conn__info.html">fuse_conn_info</a> *&#160;</td>
          <td class="paramname"><em>conn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function applies the (parsed) parameters in <em>opts</em> to the <em>conn</em> pointer. It may modify the following fields: wants, max_write, max_readahead, congestion_threshold, max_background, time_gran. A field is only set (or unset) if the corresponding option has been explicitly set. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2lib_2helper_8c_source.html#l00416">416</a> of file <a class="el" href="fuse-3_817_81-rc0_2lib_2helper_8c_source.html">helper.c</a>.</p>

</div>
</div>
<a id="a9ca301390fb5e85b85153abb1891a3f7" name="a9ca301390fb5e85b85153abb1891a3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ca301390fb5e85b85153abb1891a3f7">&#9670;&#160;</a></span>fuse_buf_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fuse_buf_copy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">enum <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#aec0ad71a3e8c357ebe7e87cdecbdbe18">fuse_buf_copy_flags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy data from one buffer vector to another</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dst</td><td>destination buffer vector </td></tr>
    <tr><td class="paramname">src</td><td>source buffer vector </td></tr>
    <tr><td class="paramname">flags</td><td>flags controlling the copy </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>actual number of bytes copied or -errno on error </dd></dl>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2lib_2buffer_8c_source.html#l00284">284</a> of file <a class="el" href="fuse-3_817_81-rc0_2lib_2buffer_8c_source.html">buffer.c</a>.</p>

</div>
</div>
<a id="a4327f41b2fe1ca84151b407169bd86c0" name="a4327f41b2fe1ca84151b407169bd86c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4327f41b2fe1ca84151b407169bd86c0">&#9670;&#160;</a></span>fuse_buf_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t fuse_buf_size </td>
          <td>(</td>
          <td class="paramtype">const struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *&#160;</td>
          <td class="paramname"><em>bufv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get total size of data in a fuse buffer vector</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufv</td><td>buffer vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size of data </dd></dl>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2lib_2buffer_8c_source.html#l00022">22</a> of file <a class="el" href="fuse-3_817_81-rc0_2lib_2buffer_8c_source.html">buffer.c</a>.</p>

</div>
</div>
<a id="af1857d2209952f49a762aff39f3cd8bd" name="af1857d2209952f49a762aff39f3cd8bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1857d2209952f49a762aff39f3cd8bd">&#9670;&#160;</a></span>fuse_daemonize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_daemonize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>foreground</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Go into the background</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">foreground</td><td>if true, stay in the foreground </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure </dd></dl>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2lib_2helper_8c_source.html#l00253">253</a> of file <a class="el" href="fuse-3_817_81-rc0_2lib_2helper_8c_source.html">helper.c</a>.</p>

</div>
</div>
<a id="aa8c278816933611a6280b9e9611441a5" name="aa8c278816933611a6280b9e9611441a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8c278816933611a6280b9e9611441a5">&#9670;&#160;</a></span>fuse_parse_conn_info_opts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct fuse_conn_info_opts * fuse_parse_conn_info_opts </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfuse__args.html">fuse_args</a> *&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function parses several command-line options that can be used to override elements of struct <a class="el" href="structfuse__conn__info.html">fuse_conn_info</a>. The pointer returned by this function should be passed to the <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a55cf81fd313a39a171275360960b0471">fuse_apply_conn_info_opts()</a> method by the file system's init() handler.</p>
<p>Before using this function, think twice if you really want these parameters to be adjustable from the command line. In most cases, they should be determined by the file system internally.</p>
<p>The following options are recognized:</p>
<p>-o max_write=N sets conn-&gt;max_write -o max_readahead=N sets conn-&gt;max_readahead -o max_background=N sets conn-&gt;max_background -o congestion_threshold=N sets conn-&gt;congestion_threshold -o async_read sets FUSE_CAP_ASYNC_READ in conn-&gt;want -o sync_read unsets FUSE_CAP_ASYNC_READ in conn-&gt;want -o atomic_o_trunc sets FUSE_CAP_ATOMIC_O_TRUNC in conn-&gt;want -o no_remote_lock Equivalent to -o no_remote_flock,no_remote_posix_lock -o no_remote_flock Unsets FUSE_CAP_FLOCK_LOCKS in conn-&gt;want -o no_remote_posix_lock Unsets FUSE_CAP_POSIX_LOCKS in conn-&gt;want -o [no_]splice_write (un-)sets FUSE_CAP_SPLICE_WRITE in conn-&gt;want -o [no_]splice_move (un-)sets FUSE_CAP_SPLICE_MOVE in conn-&gt;want -o [no_]splice_read (un-)sets FUSE_CAP_SPLICE_READ in conn-&gt;want -o [no_]auto_inval_data (un-)sets FUSE_CAP_AUTO_INVAL_DATA in conn-&gt;want -o readdirplus=no unsets FUSE_CAP_READDIRPLUS in conn-&gt;want -o readdirplus=yes sets FUSE_CAP_READDIRPLUS and unsets FUSE_CAP_READDIRPLUS_AUTO in conn-&gt;want -o readdirplus=auto sets FUSE_CAP_READDIRPLUS and FUSE_CAP_READDIRPLUS_AUTO in conn-&gt;want -o [no_]async_dio (un-)sets FUSE_CAP_ASYNC_DIO in conn-&gt;want -o [no_]writeback_cache (un-)sets FUSE_CAP_WRITEBACK_CACHE in conn-&gt;want -o time_gran=N sets conn-&gt;time_gran</p>
<p>Known options will be removed from <em>args</em>, unknown options will be passed through unchanged.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>argument vector (input+output) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>parsed options </dd></dl>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2lib_2helper_8c_source.html#l00463">463</a> of file <a class="el" href="fuse-3_817_81-rc0_2lib_2helper_8c_source.html">helper.c</a>.</p>

</div>
</div>
<a id="ad8962ec2b8ac91cc2cb9ef8da7c004aa" name="ad8962ec2b8ac91cc2cb9ef8da7c004aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8962ec2b8ac91cc2cb9ef8da7c004aa">&#9670;&#160;</a></span>fuse_pkgversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * fuse_pkgversion </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the full package version string of the library</p>
<dl class="section return"><dt>Returns</dt><dd>the package version </dd></dl>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2lib_2fuse_8c_source.html#l05218">5218</a> of file <a class="el" href="fuse-3_817_81-rc0_2lib_2fuse_8c_source.html">fuse.c</a>.</p>

</div>
</div>
<a id="adf5027f8a38b2efc03858efd7fdc756a" name="adf5027f8a38b2efc03858efd7fdc756a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf5027f8a38b2efc03858efd7fdc756a">&#9670;&#160;</a></span>fuse_pollhandle_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_pollhandle_destroy </td>
          <td>(</td>
          <td class="paramtype">struct fuse_pollhandle *&#160;</td>
          <td class="paramname"><em>ph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy poll handle</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ph</td><td>the poll handle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2lib_2fuse__lowlevel_8c_source.html#l01906">1906</a> of file <a class="el" href="fuse-3_817_81-rc0_2lib_2fuse__lowlevel_8c_source.html">fuse_lowlevel.c</a>.</p>

</div>
</div>
<a id="aeb674bbc11074c4fe520b952d6bfdd30" name="aeb674bbc11074c4fe520b952d6bfdd30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb674bbc11074c4fe520b952d6bfdd30">&#9670;&#160;</a></span>fuse_remove_signal_handlers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fuse_remove_signal_handlers </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Restore default signal handlers</p>
<p>Resets global session. After this <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a292dccc3c7b1799cb054efa2ba0c774b">fuse_set_signal_handlers()</a> may be called again.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the same session as given in <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a292dccc3c7b1799cb054efa2ba0c774b">fuse_set_signal_handlers()</a></td></tr>
  </table>
  </dd>
</dl>
<p>See also: <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a292dccc3c7b1799cb054efa2ba0c774b">fuse_set_signal_handlers()</a> </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2lib_2fuse__signals_8c_source.html#l00180">180</a> of file <a class="el" href="fuse-3_817_81-rc0_2lib_2fuse__signals_8c_source.html">fuse_signals.c</a>.</p>

</div>
</div>
<a id="a15830cd29289a75894e21f6a3ff573fa" name="a15830cd29289a75894e21f6a3ff573fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15830cd29289a75894e21f6a3ff573fa">&#9670;&#160;</a></span>fuse_set_fail_signal_handlers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_set_fail_signal_handlers </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print a stack backtrace diagnostic on critical signals ()</p>
<p>Stores session in a global variable. May only be called once per process until <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#aeb674bbc11074c4fe520b952d6bfdd30">fuse_remove_signal_handlers()</a> is called.</p>
<p>Once either of the POSIX signals arrives, the signal handler calls <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__lowlevel_8h.html#a198429f3fbc23ef29ef9971271827690">fuse_session_exit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session to exit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure</dd></dl>
<p>See also: <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#aeb674bbc11074c4fe520b952d6bfdd30">fuse_remove_signal_handlers()</a> </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2lib_2fuse__signals_8c_source.html#l00158">158</a> of file <a class="el" href="fuse-3_817_81-rc0_2lib_2fuse__signals_8c_source.html">fuse_signals.c</a>.</p>

</div>
</div>
<a id="a292dccc3c7b1799cb054efa2ba0c774b" name="a292dccc3c7b1799cb054efa2ba0c774b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292dccc3c7b1799cb054efa2ba0c774b">&#9670;&#160;</a></span>fuse_set_signal_handlers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_set_signal_handlers </td>
          <td>(</td>
          <td class="paramtype">struct fuse_session *&#160;</td>
          <td class="paramname"><em>se</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exit session on HUP, TERM and INT signals and ignore PIPE signal</p>
<p>Stores session in a global variable. May only be called once per process until <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#aeb674bbc11074c4fe520b952d6bfdd30">fuse_remove_signal_handlers()</a> is called.</p>
<p>Once either of the POSIX signals arrives, the signal handler calls <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__lowlevel_8h.html#a198429f3fbc23ef29ef9971271827690">fuse_session_exit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">se</td><td>the session to exit </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure</dd></dl>
<p>See also: <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#aeb674bbc11074c4fe520b952d6bfdd30">fuse_remove_signal_handlers()</a> </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2lib_2fuse__signals_8c_source.html#l00138">138</a> of file <a class="el" href="fuse-3_817_81-rc0_2lib_2fuse__signals_8c_source.html">fuse_signals.c</a>.</p>

</div>
</div>
<a id="ae04b2f721003f5540c71be65396c53c8" name="ae04b2f721003f5540c71be65396c53c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae04b2f721003f5540c71be65396c53c8">&#9670;&#160;</a></span>fuse_version()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fuse_version </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the version of the library</p>
<dl class="section return"><dt>Returns</dt><dd>the version </dd></dl>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2lib_2fuse_8c_source.html#l05213">5213</a> of file <a class="el" href="fuse-3_817_81-rc0_2lib_2fuse_8c_source.html">fuse.c</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
