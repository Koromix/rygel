<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libfuse: fuse_operations Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libfuse
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle"><div class="title">fuse_operations Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a60144dbd1a893008d9112e949300eb77" id="r_a60144dbd1a893008d9112e949300eb77"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a60144dbd1a893008d9112e949300eb77">getattr</a> )(const char *, struct stat *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a60144dbd1a893008d9112e949300eb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ce6e6d69dfde3ec550f22d932c5633" id="r_ab4ce6e6d69dfde3ec550f22d932c5633"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ab4ce6e6d69dfde3ec550f22d932c5633">readlink</a> )(const char *, char *, size_t)</td></tr>
<tr class="separator:ab4ce6e6d69dfde3ec550f22d932c5633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1465eb2268cec2bb5ed11cb09bbda42f" id="r_a1465eb2268cec2bb5ed11cb09bbda42f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a1465eb2268cec2bb5ed11cb09bbda42f">mknod</a> )(const char *, mode_t, dev_t)</td></tr>
<tr class="separator:a1465eb2268cec2bb5ed11cb09bbda42f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a38aa6ca60e945772d5d21b0c1c8916" id="r_a0a38aa6ca60e945772d5d21b0c1c8916"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a0a38aa6ca60e945772d5d21b0c1c8916">mkdir</a> )(const char *, mode_t)</td></tr>
<tr class="separator:a0a38aa6ca60e945772d5d21b0c1c8916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf63301a9d6e94311fa10480993801e" id="r_a8bf63301a9d6e94311fa10480993801e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a8bf63301a9d6e94311fa10480993801e">unlink</a> )(const char *)</td></tr>
<tr class="separator:a8bf63301a9d6e94311fa10480993801e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59578d18db12f0142ae1ab6e8812d55" id="r_ac59578d18db12f0142ae1ab6e8812d55"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ac59578d18db12f0142ae1ab6e8812d55">rmdir</a> )(const char *)</td></tr>
<tr class="separator:ac59578d18db12f0142ae1ab6e8812d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab86022391e56a8ad3211cf754b5b5ebe" id="r_ab86022391e56a8ad3211cf754b5b5ebe"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ab86022391e56a8ad3211cf754b5b5ebe">symlink</a> )(const char *, const char *)</td></tr>
<tr class="separator:ab86022391e56a8ad3211cf754b5b5ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cc0238ae11defe11755c825d51ca93" id="r_a79cc0238ae11defe11755c825d51ca93"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a79cc0238ae11defe11755c825d51ca93">rename</a> )(const char *, const char *, unsigned int flags)</td></tr>
<tr class="separator:a79cc0238ae11defe11755c825d51ca93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b234c43e826c6a690d80ea895a17f61" id="r_a1b234c43e826c6a690d80ea895a17f61"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a1b234c43e826c6a690d80ea895a17f61">link</a> )(const char *, const char *)</td></tr>
<tr class="separator:a1b234c43e826c6a690d80ea895a17f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dc9c3d84129b30d63d00e59c6851d5" id="r_ac0dc9c3d84129b30d63d00e59c6851d5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ac0dc9c3d84129b30d63d00e59c6851d5">chmod</a> )(const char *, mode_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:ac0dc9c3d84129b30d63d00e59c6851d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb391676f601fda80cc866dcc977b83" id="r_abfb391676f601fda80cc866dcc977b83"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#abfb391676f601fda80cc866dcc977b83">chown</a> )(const char *, uid_t, gid_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:abfb391676f601fda80cc866dcc977b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103927b9fe73c5b7cb5ef43bccac5993" id="r_a103927b9fe73c5b7cb5ef43bccac5993"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a103927b9fe73c5b7cb5ef43bccac5993">truncate</a> )(const char *, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a103927b9fe73c5b7cb5ef43bccac5993"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b98c3f7ab97cc2ef8f9b1d9dc0709d" id="r_a14b98c3f7ab97cc2ef8f9b1d9dc0709d"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a14b98c3f7ab97cc2ef8f9b1d9dc0709d">open</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a14b98c3f7ab97cc2ef8f9b1d9dc0709d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1c6b4ce1845de56863f8b7939501b5" id="r_a2a1c6b4ce1845de56863f8b7939501b5"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a2a1c6b4ce1845de56863f8b7939501b5">read</a> )(const char *, char *, size_t, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a2a1c6b4ce1845de56863f8b7939501b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a897d1ece4b8b04c92d97b97b2dbf9768" id="r_a897d1ece4b8b04c92d97b97b2dbf9768"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a897d1ece4b8b04c92d97b97b2dbf9768">write</a> )(const char *, const char *, size_t, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a897d1ece4b8b04c92d97b97b2dbf9768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e765e29122e7b6b533dc99849a52655" id="r_a4e765e29122e7b6b533dc99849a52655"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a4e765e29122e7b6b533dc99849a52655">statfs</a> )(const char *, struct statvfs *)</td></tr>
<tr class="separator:a4e765e29122e7b6b533dc99849a52655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4ec9c309072a92dd82ddb20efa4ab14" id="r_ad4ec9c309072a92dd82ddb20efa4ab14"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ad4ec9c309072a92dd82ddb20efa4ab14">flush</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:ad4ec9c309072a92dd82ddb20efa4ab14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac8718cdfc1ee273a44831a27393419" id="r_abac8718cdfc1ee273a44831a27393419"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#abac8718cdfc1ee273a44831a27393419">release</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:abac8718cdfc1ee273a44831a27393419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bdd6f43ba390a54ac360541c56b528" id="r_a92bdd6f43ba390a54ac360541c56b528"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a92bdd6f43ba390a54ac360541c56b528">fsync</a> )(const char *, int, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a92bdd6f43ba390a54ac360541c56b528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988ced7091c2821daa208e6c96d8b598" id="r_a988ced7091c2821daa208e6c96d8b598"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a988ced7091c2821daa208e6c96d8b598">setxattr</a> )(const char *, const char *, const char *, size_t, int)</td></tr>
<tr class="separator:a988ced7091c2821daa208e6c96d8b598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21503c64fe2990c8a599f5ba339a8f2" id="r_ae21503c64fe2990c8a599f5ba339a8f2"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ae21503c64fe2990c8a599f5ba339a8f2">getxattr</a> )(const char *, const char *, char *, size_t)</td></tr>
<tr class="separator:ae21503c64fe2990c8a599f5ba339a8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4a9c361ce48406f07d5a08ab03f5de8" id="r_ab4a9c361ce48406f07d5a08ab03f5de8"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ab4a9c361ce48406f07d5a08ab03f5de8">listxattr</a> )(const char *, char *, size_t)</td></tr>
<tr class="separator:ab4a9c361ce48406f07d5a08ab03f5de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e54de801a0e0d7019e4579112ecc477" id="r_a5e54de801a0e0d7019e4579112ecc477"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a5e54de801a0e0d7019e4579112ecc477">removexattr</a> )(const char *, const char *)</td></tr>
<tr class="separator:a5e54de801a0e0d7019e4579112ecc477"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1813889bc5e6e0087a936b7abe8b923f" id="r_a1813889bc5e6e0087a936b7abe8b923f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a1813889bc5e6e0087a936b7abe8b923f">opendir</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a1813889bc5e6e0087a936b7abe8b923f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc01d3622754fc7de8e643249e73268d" id="r_adc01d3622754fc7de8e643249e73268d"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#adc01d3622754fc7de8e643249e73268d">readdir</a> )(const char *, void *, <a class="el" href="include_2fuse_8h.html#a7dd132de66a5cc2add2a4eff5d435660">fuse_fill_dir_t</a>, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, enum <a class="el" href="include_2fuse_8h.html#af2bcf2a473b41b3cc8da8c079656a074">fuse_readdir_flags</a>)</td></tr>
<tr class="separator:adc01d3622754fc7de8e643249e73268d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a729e53d36acc05a7a8985a1a3bbfac1e" id="r_a729e53d36acc05a7a8985a1a3bbfac1e"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a729e53d36acc05a7a8985a1a3bbfac1e">releasedir</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a729e53d36acc05a7a8985a1a3bbfac1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba5cc1fe9a63ec152ceb19656f243256" id="r_aba5cc1fe9a63ec152ceb19656f243256"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#aba5cc1fe9a63ec152ceb19656f243256">fsyncdir</a> )(const char *, int, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:aba5cc1fe9a63ec152ceb19656f243256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a1f9562a38871caaf4fc2de7ea5b470" id="r_a3a1f9562a38871caaf4fc2de7ea5b470"><td class="memItemLeft" align="right" valign="top">void *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a3a1f9562a38871caaf4fc2de7ea5b470">init</a> )(struct <a class="el" href="structfuse__conn__info.html">fuse_conn_info</a> *conn, struct <a class="el" href="structfuse__config.html">fuse_config</a> *cfg)</td></tr>
<tr class="separator:a3a1f9562a38871caaf4fc2de7ea5b470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7d1ddcba2715b1d8be92ba0ac0c187" id="r_a4b7d1ddcba2715b1d8be92ba0ac0c187"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a4b7d1ddcba2715b1d8be92ba0ac0c187">destroy</a> )(void *private_data)</td></tr>
<tr class="separator:a4b7d1ddcba2715b1d8be92ba0ac0c187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2248db35e200265f7fb9a18348229858" id="r_a2248db35e200265f7fb9a18348229858"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a2248db35e200265f7fb9a18348229858">access</a> )(const char *, int)</td></tr>
<tr class="separator:a2248db35e200265f7fb9a18348229858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97243e0f9268a96236bc3b6f2bacee17" id="r_a97243e0f9268a96236bc3b6f2bacee17"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a97243e0f9268a96236bc3b6f2bacee17">create</a> )(const char *, mode_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a97243e0f9268a96236bc3b6f2bacee17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c3fff5cf0c1c2003d117e764b9a76fd" id="r_a1c3fff5cf0c1c2003d117e764b9a76fd"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a1c3fff5cf0c1c2003d117e764b9a76fd">lock</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, int cmd, struct <a class="el" href="structfuse__operations.html#ad5968d566dab370974043fcf4271eb25">flock</a> *)</td></tr>
<tr class="separator:a1c3fff5cf0c1c2003d117e764b9a76fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14b47789c53aa750ed2cfea92cacc9c9" id="r_a14b47789c53aa750ed2cfea92cacc9c9"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a14b47789c53aa750ed2cfea92cacc9c9">utimens</a> )(const char *, const struct timespec tv[2], struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a14b47789c53aa750ed2cfea92cacc9c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3f3482e33a0eada0292350d76b82901" id="r_ae3f3482e33a0eada0292350d76b82901"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ae3f3482e33a0eada0292350d76b82901">bmap</a> )(const char *, size_t blocksize, uint64_t *idx)</td></tr>
<tr class="separator:ae3f3482e33a0eada0292350d76b82901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b7b69192ccea64059182be90d3d63b" id="r_ad5b7b69192ccea64059182be90d3d63b"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ad5b7b69192ccea64059182be90d3d63b">ioctl</a> )(const char *, unsigned int cmd, void *arg, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, unsigned int flags, void *data)</td></tr>
<tr class="separator:ad5b7b69192ccea64059182be90d3d63b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c02838d30391c09dd5213edc61e106a" id="r_a2c02838d30391c09dd5213edc61e106a"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a2c02838d30391c09dd5213edc61e106a">poll</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, struct fuse_pollhandle *ph, unsigned *reventsp)</td></tr>
<tr class="separator:a2c02838d30391c09dd5213edc61e106a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f400083a03ddcc43e47ce126b6761f" id="r_a89f400083a03ddcc43e47ce126b6761f"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a89f400083a03ddcc43e47ce126b6761f">write_buf</a> )(const char *, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *buf, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a89f400083a03ddcc43e47ce126b6761f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ecbe844d937ffbbe135958bcb28a719" id="r_a1ecbe844d937ffbbe135958bcb28a719"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a1ecbe844d937ffbbe135958bcb28a719">read_buf</a> )(const char *, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> **bufp, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a1ecbe844d937ffbbe135958bcb28a719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5968d566dab370974043fcf4271eb25" id="r_ad5968d566dab370974043fcf4271eb25"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#ad5968d566dab370974043fcf4271eb25">flock</a> )(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, int op)</td></tr>
<tr class="separator:ad5968d566dab370974043fcf4271eb25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa8203e4bfa71d62c15deb5dffe4867" id="r_a4fa8203e4bfa71d62c15deb5dffe4867"><td class="memItemLeft" align="right" valign="top">int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a4fa8203e4bfa71d62c15deb5dffe4867">fallocate</a> )(const char *, int, off_t, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a4fa8203e4bfa71d62c15deb5dffe4867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dab2194663f561ef7db54de2ca35694" id="r_a8dab2194663f561ef7db54de2ca35694"><td class="memItemLeft" align="right" valign="top">ssize_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a8dab2194663f561ef7db54de2ca35694">copy_file_range</a> )(const char *path_in, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi_in, off_t offset_in, const char *path_out, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi_out, off_t offset_out, size_t size, int flags)</td></tr>
<tr class="separator:a8dab2194663f561ef7db54de2ca35694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862caf337571d43bb47630c81048a4b9" id="r_a862caf337571d43bb47630c81048a4b9"><td class="memItemLeft" align="right" valign="top">off_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__operations.html#a862caf337571d43bb47630c81048a4b9">lseek</a> )(const char *, off_t off, int whence, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td></tr>
<tr class="separator:a862caf337571d43bb47630c81048a4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The file system operations:</p>
<p>Most of these should work very similarly to the well known UNIX file system operations. A major exception is that instead of returning an error in 'errno', the operation should return the negated error value (-errno) directly.</p>
<p>All methods are optional, but some are essential for a useful filesystem (e.g. getattr). Open, flush, release, fsync, opendir, releasedir, fsyncdir, access, create, truncate, lock, init and destroy are special purpose methods, without which a full featured filesystem can still be implemented.</p>
<p>In general, all methods are expected to perform any necessary permission checking. However, a filesystem may delegate this task to the kernel by passing the <code>default_permissions</code> mount option to <code>fuse_new()</code>. In this case, methods will only be called if the kernel's permission check has succeeded.</p>
<p>Almost all operations take a path which can be of any length. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00349">349</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="a2248db35e200265f7fb9a18348229858" name="a2248db35e200265f7fb9a18348229858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2248db35e200265f7fb9a18348229858">&#9670;&#160;</a></span>access</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::access)(const char *, int)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check file access permissions</p>
<p>This will be called for the <a class="el" href="structfuse__operations.html#a2248db35e200265f7fb9a18348229858">access()</a> system call. If the 'default_permissions' mount option is given, this method is not called.</p>
<p>This method is not called under Linux kernel versions 2.4.x </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00660">660</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="ae3f3482e33a0eada0292350d76b82901" name="ae3f3482e33a0eada0292350d76b82901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3f3482e33a0eada0292350d76b82901">&#9670;&#160;</a></span>bmap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::bmap)(const char *, size_t blocksize, uint64_t *idx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map block index within file to block index within device</p>
<p>Note: This makes sense only for block device backed filesystems mounted with the 'blkdev' option </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00728">728</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="ac0dc9c3d84129b30d63d00e59c6851d5" name="ac0dc9c3d84129b30d63d00e59c6851d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0dc9c3d84129b30d63d00e59c6851d5">&#9670;&#160;</a></span>chmod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::chmod)(const char *, mode_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the permission bits of a file</p>
<p><code>fi</code> will always be NULL if the file is not currently open, but may also be NULL if the file is open. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00417">417</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="abfb391676f601fda80cc866dcc977b83" name="abfb391676f601fda80cc866dcc977b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb391676f601fda80cc866dcc977b83">&#9670;&#160;</a></span>chown</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::chown)(const char *, uid_t, gid_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the owner and group of a file</p>
<p><code>fi</code> will always be NULL if the file is not currently open, but may also be NULL if the file is open.</p>
<p>Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is expected to reset the setuid and setgid bits. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00427">427</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a8dab2194663f561ef7db54de2ca35694" name="a8dab2194663f561ef7db54de2ca35694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dab2194663f561ef7db54de2ca35694">&#9670;&#160;</a></span>copy_file_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t(* fuse_operations::copy_file_range)(const char *path_in, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi_in, off_t offset_in, const char *path_out, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi_out, off_t offset_out, size_t size, int flags)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a range of data from one file to another</p>
<p>Performs an optimized copy between two file descriptors without the additional cost of transferring data through the FUSE kernel module to user space (glibc) and then back into the FUSE filesystem again.</p>
<p>In case this method is not implemented, applications are expected to fall back to a regular file copy. (Some glibc versions did this emulation automatically, but the emulation has been removed from all glibc release branches.) </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00843">843</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a97243e0f9268a96236bc3b6f2bacee17" name="a97243e0f9268a96236bc3b6f2bacee17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97243e0f9268a96236bc3b6f2bacee17">&#9670;&#160;</a></span>create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::create)(const char *, mode_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create and open a file</p>
<p>If the file does not exist, first create it with the specified mode, and then open it.</p>
<p>If this method is not implemented or under Linux kernel versions earlier than 2.6.15, the <a class="el" href="structfuse__operations.html#a1465eb2268cec2bb5ed11cb09bbda42f">mknod()</a> and <a class="el" href="structfuse__operations.html#a14b98c3f7ab97cc2ef8f9b1d9dc0709d">open()</a> methods will be called instead. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00672">672</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a4b7d1ddcba2715b1d8be92ba0ac0c187" name="a4b7d1ddcba2715b1d8be92ba0ac0c187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7d1ddcba2715b1d8be92ba0ac0c187">&#9670;&#160;</a></span>destroy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_operations::destroy)(void *private_data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clean up filesystem</p>
<p>Called on filesystem exit. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00649">649</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a4fa8203e4bfa71d62c15deb5dffe4867" name="a4fa8203e4bfa71d62c15deb5dffe4867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa8203e4bfa71d62c15deb5dffe4867">&#9670;&#160;</a></span>fallocate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::fallocate)(const char *, int, off_t, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates space for an open file</p>
<p>This function ensures that required space is allocated for specified file. If this function returns success then any subsequent write request to specified range is guaranteed not to fail because of lack of space on the file system media. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00828">828</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="ad5968d566dab370974043fcf4271eb25" name="ad5968d566dab370974043fcf4271eb25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5968d566dab370974043fcf4271eb25">&#9670;&#160;</a></span>flock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::flock)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, int op)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform BSD file locking operation</p>
<p>The op argument will be either LOCK_SH, LOCK_EX or LOCK_UN</p>
<p>Nonblocking requests will be indicated by ORing LOCK_NB to the above operations</p>
<p>For more information see the <a class="el" href="structfuse__operations.html#ad5968d566dab370974043fcf4271eb25">flock(2)</a> manual page.</p>
<p>Additionally fi-&gt;owner will be set to a value unique to this open file. This same value will be supplied to -&gt;<a class="el" href="structfuse__operations.html#abac8718cdfc1ee273a44831a27393419">release()</a> when the file is released.</p>
<p>Note: if this method is not implemented, the kernel will still allow file locking to work locally. Hence it is only interesting for network filesystems and similar. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00818">818</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="ad4ec9c309072a92dd82ddb20efa4ab14" name="ad4ec9c309072a92dd82ddb20efa4ab14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4ec9c309072a92dd82ddb20efa4ab14">&#9670;&#160;</a></span>flush</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::flush)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Possibly flush cached data</p>
<p>BIG NOTE: This is not equivalent to <a class="el" href="structfuse__operations.html#a92bdd6f43ba390a54ac360541c56b528">fsync()</a>. It's not a request to sync dirty data.</p>
<p>Flush is called on each close() of a file descriptor, as opposed to release which is called on the close of the last file descriptor for a file. Under Linux, errors returned by <a class="el" href="structfuse__operations.html#ad4ec9c309072a92dd82ddb20efa4ab14">flush()</a> will be passed to userspace as errors from close(), so <a class="el" href="structfuse__operations.html#ad4ec9c309072a92dd82ddb20efa4ab14">flush()</a> is a good place to write back any cached dirty data. However, many applications ignore errors on close(), and on non-Linux systems, close() may succeed even if <a class="el" href="structfuse__operations.html#ad4ec9c309072a92dd82ddb20efa4ab14">flush()</a> returns an error. For these reasons, filesystems should not assume that errors returned by flush will ever be noticed or even delivered.</p>
<p>NOTE: The <a class="el" href="structfuse__operations.html#ad4ec9c309072a92dd82ddb20efa4ab14">flush()</a> method may be called more than once for each <a class="el" href="structfuse__operations.html#a14b98c3f7ab97cc2ef8f9b1d9dc0709d">open()</a>. This happens if more than one file descriptor refers to an open file handle, e.g. due to dup(), dup2() or fork() calls. It is not possible to determine if a flush is final, so each flush should be treated equally. Multiple write-flush sequences are relatively rare, so this shouldn't be a problem.</p>
<p>Filesystems shouldn't assume that flush will be called at any particular point. It may be called more times than expected, or not at all. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00546">546</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a92bdd6f43ba390a54ac360541c56b528" name="a92bdd6f43ba390a54ac360541c56b528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92bdd6f43ba390a54ac360541c56b528">&#9670;&#160;</a></span>fsync</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::fsync)(const char *, int, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronize file contents</p>
<p>If the datasync parameter is non-zero, then only the user data should be flushed, not the meta data. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00567">567</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="aba5cc1fe9a63ec152ceb19656f243256" name="aba5cc1fe9a63ec152ceb19656f243256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba5cc1fe9a63ec152ceb19656f243256">&#9670;&#160;</a></span>fsyncdir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::fsyncdir)(const char *, int, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Synchronize directory contents</p>
<p>If the directory has been removed after the call to opendir, the path parameter will be NULL.</p>
<p>If the datasync parameter is non-zero, then only the user data should be flushed, not the meta data </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00631">631</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a60144dbd1a893008d9112e949300eb77" name="a60144dbd1a893008d9112e949300eb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60144dbd1a893008d9112e949300eb77">&#9670;&#160;</a></span>getattr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::getattr)(const char *, struct stat *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get file attributes.</p>
<p>Similar to stat(). The 'st_dev' and 'st_blksize' fields are ignored. The 'st_ino' field is ignored except if the 'use_ino' mount option is given. In that case it is passed to userspace, but libfuse and the kernel will still assign a different inode for internal use (called the "nodeid").</p>
<p><code>fi</code> will always be NULL if the file is not currently open, but may also be NULL if the file is open. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00361">361</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="ae21503c64fe2990c8a599f5ba339a8f2" name="ae21503c64fe2990c8a599f5ba339a8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21503c64fe2990c8a599f5ba339a8f2">&#9670;&#160;</a></span>getxattr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::getxattr)(const char *, const char *, char *, size_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get extended attributes </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00573">573</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a3a1f9562a38871caaf4fc2de7ea5b470" name="a3a1f9562a38871caaf4fc2de7ea5b470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a1f9562a38871caaf4fc2de7ea5b470">&#9670;&#160;</a></span>init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void *(* fuse_operations::init)(struct <a class="el" href="structfuse__conn__info.html">fuse_conn_info</a> *conn, struct <a class="el" href="structfuse__config.html">fuse_config</a> *cfg)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize filesystem</p>
<p>The return value will passed in the <code>private_data</code> field of <code>struct <a class="el" href="structfuse__context.html">fuse_context</a></code> to all file operations, and as a parameter to the <a class="el" href="structfuse__operations.html#a4b7d1ddcba2715b1d8be92ba0ac0c187">destroy()</a> method. It overrides the initial value provided to fuse_main() / fuse_new(). </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00641">641</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="ad5b7b69192ccea64059182be90d3d63b" name="ad5b7b69192ccea64059182be90d3d63b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b7b69192ccea64059182be90d3d63b">&#9670;&#160;</a></span>ioctl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::ioctl)(const char *, unsigned int cmd, void *arg, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, unsigned int flags, void *data)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ioctl</p>
<p>flags will have FUSE_IOCTL_COMPAT set for 32bit ioctls in 64bit environment. The size and direction of data is determined by <em>IOC</em>*() decoding of cmd. For _IOC_NONE, data will be NULL, for _IOC_WRITE data is out area, for _IOC_READ in area and if both are set in/out area. In all non-NULL cases, the area is of _IOC_SIZE(cmd) bytes.</p>
<p>If flags has FUSE_IOCTL_DIR then the <a class="el" href="structfuse__file__info.html">fuse_file_info</a> refers to a directory file handle.</p>
<p>Note : the unsigned long request submitted by the application is truncated to 32 bits. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00750">750</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a1b234c43e826c6a690d80ea895a17f61" name="a1b234c43e826c6a690d80ea895a17f61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b234c43e826c6a690d80ea895a17f61">&#9670;&#160;</a></span>link</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::link)(const char *, const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a hard link to a file </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00410">410</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="ab4a9c361ce48406f07d5a08ab03f5de8" name="ab4a9c361ce48406f07d5a08ab03f5de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4a9c361ce48406f07d5a08ab03f5de8">&#9670;&#160;</a></span>listxattr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::listxattr)(const char *, char *, size_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List extended attributes </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00576">576</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a1c3fff5cf0c1c2003d117e764b9a76fd" name="a1c3fff5cf0c1c2003d117e764b9a76fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c3fff5cf0c1c2003d117e764b9a76fd">&#9670;&#160;</a></span>lock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::lock)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, int cmd, struct <a class="el" href="structfuse__operations.html#ad5968d566dab370974043fcf4271eb25">flock</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform POSIX file locking operation</p>
<p>The cmd argument will be either F_GETLK, F_SETLK or F_SETLKW.</p>
<p>For the meaning of fields in 'struct flock' see the man page for fcntl(2). The l_whence field will always be set to SEEK_SET.</p>
<p>For checking lock ownership, the 'fuse_file_info-&gt;owner' argument must be used.</p>
<p>For F_GETLK operation, the library will first check currently held locks, and if a conflicting lock is found it will return information without calling this method. This ensures, that for local locks the l_pid field is correctly filled in. The results may not be accurate in case of race conditions and in the presence of hard links, but it's unlikely that an application would rely on accurate GETLK results in these cases. If a conflicting lock is not found, this method will be called, and the filesystem may fill out l_pid by a meaningful value, or it may leave this field zero.</p>
<p>For F_SETLK and F_SETLKW the l_pid field will be set to the pid of the process performing the locking operation.</p>
<p>Note: if this method is not implemented, the kernel will still allow file locking to work locally. Hence it is only interesting for network filesystems and similar. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00704">704</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a862caf337571d43bb47630c81048a4b9" name="a862caf337571d43bb47630c81048a4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862caf337571d43bb47630c81048a4b9">&#9670;&#160;</a></span>lseek</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">off_t(* fuse_operations::lseek)(const char *, off_t off, int whence, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find next data or hole after the specified offset </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00852">852</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a0a38aa6ca60e945772d5d21b0c1c8916" name="a0a38aa6ca60e945772d5d21b0c1c8916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a38aa6ca60e945772d5d21b0c1c8916">&#9670;&#160;</a></span>mkdir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::mkdir)(const char *, mode_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a directory</p>
<p>Note that the mode argument may not have the type specification bits set, i.e. S_ISDIR(mode) can be false. To obtain the correct directory type bits use mode|S_IFDIR </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00387">387</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a1465eb2268cec2bb5ed11cb09bbda42f" name="a1465eb2268cec2bb5ed11cb09bbda42f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1465eb2268cec2bb5ed11cb09bbda42f">&#9670;&#160;</a></span>mknod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::mknod)(const char *, mode_t, dev_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a file node</p>
<p>This is called for creation of all non-directory, non-symlink nodes. If the filesystem defines a <a class="el" href="structfuse__operations.html#a97243e0f9268a96236bc3b6f2bacee17">create()</a> method, then for regular files that will be called instead. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00379">379</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a14b98c3f7ab97cc2ef8f9b1d9dc0709d" name="a14b98c3f7ab97cc2ef8f9b1d9dc0709d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b98c3f7ab97cc2ef8f9b1d9dc0709d">&#9670;&#160;</a></span>open</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::open)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a file</p>
<p>Open flags are available in fi-&gt;flags. The following rules apply.</p>
<ul>
<li>Creation (O_CREAT, O_EXCL, O_NOCTTY) flags will be filtered out / handled by the kernel.</li>
<li>Access modes (O_RDONLY, O_WRONLY, O_RDWR, O_EXEC, O_SEARCH) should be used by the filesystem to check if the operation is permitted. If the <code>-o default_permissions</code> mount option is given, this check is already done by the kernel before calling <a class="el" href="structfuse__operations.html#a14b98c3f7ab97cc2ef8f9b1d9dc0709d">open()</a> and may thus be omitted by the filesystem.</li>
<li>When writeback caching is enabled, the kernel may send read requests even for files opened with O_WRONLY. The filesystem should be prepared to handle this.</li>
<li>When writeback caching is disabled, the filesystem is expected to properly handle the O_APPEND flag and ensure that each write is appending to the end of the file.</li>
<li>When writeback caching is enabled, the kernel will handle O_APPEND. However, unless all changes to the file come through the kernel this will not work reliably. The filesystem should thus either ignore the O_APPEND flag (and let the kernel handle it), or return an error (indicating that reliably O_APPEND is not available).</li>
</ul>
<p>Filesystem may store an arbitrary file handle (pointer, index, etc) in fi-&gt;fh, and use this in other all other file operations (read, write, flush, release, fsync).</p>
<p>Filesystem may also implement stateless file I/O and not store anything in fi-&gt;fh.</p>
<p>There are also some flags (direct_io, keep_cache) which the filesystem may set in fi, to change the way the file is opened. See <a class="el" href="structfuse__file__info.html">fuse_file_info</a> structure in &lt;fuse_common.h&gt; for more details.</p>
<p>If this request is answered with an error code of ENOSYS and FUSE_CAP_NO_OPEN_SUPPORT is set in <code><a class="el" href="structfuse__conn__info.html#ad43a4091adae5d5cc42c61995618cebc">fuse_conn_info.capable</a></code>, this is treated as success and future calls to open will also succeed without being sent to the filesystem process. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00486">486</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a1813889bc5e6e0087a936b7abe8b923f" name="a1813889bc5e6e0087a936b7abe8b923f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1813889bc5e6e0087a936b7abe8b923f">&#9670;&#160;</a></span>opendir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::opendir)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open directory</p>
<p>Unless the 'default_permissions' mount option is given, this method should check if opendir is permitted for this directory. Optionally opendir may also return an arbitrary filehandle in the <a class="el" href="structfuse__file__info.html">fuse_file_info</a> structure, which will be passed to readdir, releasedir and fsyncdir. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00589">589</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a2c02838d30391c09dd5213edc61e106a" name="a2c02838d30391c09dd5213edc61e106a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c02838d30391c09dd5213edc61e106a">&#9670;&#160;</a></span>poll</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::poll)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, struct fuse_pollhandle *ph, unsigned *reventsp)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Poll for IO readiness events</p>
<p>Note: If ph is non-NULL, the client should notify when IO readiness events occur by calling fuse_notify_poll() with the specified ph.</p>
<p>Regardless of the number of times poll with a non-NULL ph is received, single notification is enough to clear all. Notifying more times incurs overhead but doesn't harm correctness.</p>
<p>The callee is responsible for destroying ph with <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#adf5027f8a38b2efc03858efd7fdc756a">fuse_pollhandle_destroy()</a> when no longer in use. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00769">769</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a2a1c6b4ce1845de56863f8b7939501b5" name="a2a1c6b4ce1845de56863f8b7939501b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a1c6b4ce1845de56863f8b7939501b5">&#9670;&#160;</a></span>read</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::read)(const char *, char *, size_t, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read data from an open file</p>
<p>Read should return exactly the number of bytes requested except on EOF or error, otherwise the rest of the data will be substituted with zeroes. An exception to this is when the 'direct_io' mount option is specified, in which case the return value of the read system call will reflect the return value of this operation. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00497">497</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a1ecbe844d937ffbbe135958bcb28a719" name="a1ecbe844d937ffbbe135958bcb28a719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ecbe844d937ffbbe135958bcb28a719">&#9670;&#160;</a></span>read_buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::read_buf)(const char *, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> **bufp, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Store data from an open file in a buffer</p>
<p>Similar to the <a class="el" href="structfuse__operations.html#a2a1c6b4ce1845de56863f8b7939501b5">read()</a> method, but data is stored and returned in a generic buffer.</p>
<p>No actual copying of data has to take place, the source file descriptor may simply be stored in the buffer for later data transfer.</p>
<p>The buffer must be allocated dynamically and stored at the location pointed to by bufp. If the buffer contains memory regions, they too must be allocated using malloc(). The allocated memory will be freed by the caller. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00798">798</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="adc01d3622754fc7de8e643249e73268d" name="adc01d3622754fc7de8e643249e73268d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc01d3622754fc7de8e643249e73268d">&#9670;&#160;</a></span>readdir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::readdir)(const char *, void *, <a class="el" href="include_2fuse_8h.html#a7dd132de66a5cc2add2a4eff5d435660">fuse_fill_dir_t</a>, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *, enum <a class="el" href="include_2fuse_8h.html#af2bcf2a473b41b3cc8da8c079656a074">fuse_readdir_flags</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read directory</p>
<p>The filesystem may choose between two modes of operation:</p>
<p>1) The readdir implementation ignores the offset parameter, and passes zero to the filler function's offset. The filler function will not return '1' (unless an error happens), so the whole directory is read in a single readdir operation.</p>
<p>2) The readdir implementation keeps track of the offsets of the directory entries. It uses the offset parameter and always passes non-zero offset to the filler function. When the buffer is full (or an error happens) the filler function will return '1'.</p>
<p>When FUSE_READDIR_PLUS is not set, only some parameters of the fill function (the fuse_fill_dir_t parameter) are actually used: The file type (which is part of stat::st_mode) is used. And if <a class="el" href="structfuse__config.html#a80ab01a84b8cb4856e80d676a0c22e1b">fuse_config::use_ino</a> is set, the inode (stat::st_ino) is also used. The other fields are ignored when FUSE_READDIR_PLUS is not set. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00613">613</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="ab4ce6e6d69dfde3ec550f22d932c5633" name="ab4ce6e6d69dfde3ec550f22d932c5633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ce6e6d69dfde3ec550f22d932c5633">&#9670;&#160;</a></span>readlink</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::readlink)(const char *, char *, size_t)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the target of a symbolic link</p>
<p>The buffer should be filled with a null terminated string. The buffer size argument includes the space for the terminating null character. If the linkname is too long to fit in the buffer, it should be truncated. The return value should be 0 for success. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00371">371</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="abac8718cdfc1ee273a44831a27393419" name="abac8718cdfc1ee273a44831a27393419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac8718cdfc1ee273a44831a27393419">&#9670;&#160;</a></span>release</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::release)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release an open file</p>
<p>Release is called when there are no more references to an open file: all file descriptors are closed and all memory mappings are unmapped.</p>
<p>For every <a class="el" href="structfuse__operations.html#a14b98c3f7ab97cc2ef8f9b1d9dc0709d">open()</a> call there will be exactly one <a class="el" href="structfuse__operations.html#abac8718cdfc1ee273a44831a27393419">release()</a> call with the same flags and file handle. It is possible to have a file opened more than once, in which case only the last release will mean, that no more reads/writes will happen on the file. The return value of release is ignored. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00560">560</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a729e53d36acc05a7a8985a1a3bbfac1e" name="a729e53d36acc05a7a8985a1a3bbfac1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a729e53d36acc05a7a8985a1a3bbfac1e">&#9670;&#160;</a></span>releasedir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::releasedir)(const char *, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release directory</p>
<p>If the directory has been removed after the call to opendir, the path parameter will be NULL. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00621">621</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a5e54de801a0e0d7019e4579112ecc477" name="a5e54de801a0e0d7019e4579112ecc477"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e54de801a0e0d7019e4579112ecc477">&#9670;&#160;</a></span>removexattr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::removexattr)(const char *, const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove extended attributes </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00579">579</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a79cc0238ae11defe11755c825d51ca93" name="a79cc0238ae11defe11755c825d51ca93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cc0238ae11defe11755c825d51ca93">&#9670;&#160;</a></span>rename</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::rename)(const char *, const char *, unsigned int flags)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rename a file</p>
<p><em>flags</em> may be <code>RENAME_EXCHANGE</code> or <code>RENAME_NOREPLACE</code>. If RENAME_NOREPLACE is specified, the filesystem must not overwrite <em>newname</em> if it exists and return an error instead. If <code>RENAME_EXCHANGE</code> is specified, the filesystem must atomically exchange the two files, i.e. both must exist and neither may be deleted. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00407">407</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="ac59578d18db12f0142ae1ab6e8812d55" name="ac59578d18db12f0142ae1ab6e8812d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59578d18db12f0142ae1ab6e8812d55">&#9670;&#160;</a></span>rmdir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::rmdir)(const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a directory </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00393">393</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a988ced7091c2821daa208e6c96d8b598" name="a988ced7091c2821daa208e6c96d8b598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988ced7091c2821daa208e6c96d8b598">&#9670;&#160;</a></span>setxattr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::setxattr)(const char *, const char *, const char *, size_t, int)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set extended attributes </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00570">570</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a4e765e29122e7b6b533dc99849a52655" name="a4e765e29122e7b6b533dc99849a52655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e765e29122e7b6b533dc99849a52655">&#9670;&#160;</a></span>statfs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::statfs)(const char *, struct statvfs *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get file system statistics</p>
<p>The 'f_favail', 'f_fsid' and 'f_flag' fields are ignored </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00516">516</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="ab86022391e56a8ad3211cf754b5b5ebe" name="ab86022391e56a8ad3211cf754b5b5ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab86022391e56a8ad3211cf754b5b5ebe">&#9670;&#160;</a></span>symlink</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::symlink)(const char *, const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a symbolic link </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00396">396</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a103927b9fe73c5b7cb5ef43bccac5993" name="a103927b9fe73c5b7cb5ef43bccac5993"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103927b9fe73c5b7cb5ef43bccac5993">&#9670;&#160;</a></span>truncate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::truncate)(const char *, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the size of a file</p>
<p><code>fi</code> will always be NULL if the file is not currently open, but may also be NULL if the file is open.</p>
<p>Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is expected to reset the setuid and setgid bits. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00437">437</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a8bf63301a9d6e94311fa10480993801e" name="a8bf63301a9d6e94311fa10480993801e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf63301a9d6e94311fa10480993801e">&#9670;&#160;</a></span>unlink</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::unlink)(const char *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a file </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00390">390</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a14b47789c53aa750ed2cfea92cacc9c9" name="a14b47789c53aa750ed2cfea92cacc9c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14b47789c53aa750ed2cfea92cacc9c9">&#9670;&#160;</a></span>utimens</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::utimens)(const char *, const struct timespec tv[2], struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the access and modification times of a file with nanosecond resolution</p>
<p>This supersedes the old utime() interface. New applications should use this.</p>
<p><code>fi</code> will always be NULL if the file is not currently open, but may also be NULL if the file is open.</p>
<p>See the utimensat(2) man page for details. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00719">719</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a897d1ece4b8b04c92d97b97b2dbf9768" name="a897d1ece4b8b04c92d97b97b2dbf9768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a897d1ece4b8b04c92d97b97b2dbf9768">&#9670;&#160;</a></span>write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::write)(const char *, const char *, size_t, off_t, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write data to an open file</p>
<p>Write should return exactly the number of bytes requested except on error. An exception to this is when the 'direct_io' mount option is specified (see read operation).</p>
<p>Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is expected to reset the setuid and setgid bits. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00509">509</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<a id="a89f400083a03ddcc43e47ce126b6761f" name="a89f400083a03ddcc43e47ce126b6761f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89f400083a03ddcc43e47ce126b6761f">&#9670;&#160;</a></span>write_buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int(* fuse_operations::write_buf)(const char *, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *buf, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write contents of buffer to an open file</p>
<p>Similar to the <a class="el" href="structfuse__operations.html#a897d1ece4b8b04c92d97b97b2dbf9768">write()</a> method, but data is supplied in a generic buffer. Use <a class="el" href="fuse-3_817_81-rc0_2include_2fuse__common_8h.html#a9ca301390fb5e85b85153abb1891a3f7">fuse_buf_copy()</a> to transfer data to the destination.</p>
<p>Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is expected to reset the setuid and setgid bits. </p>

<p class="definition">Definition at line <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html#l00781">781</a> of file <a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>fuse-3.17.1-rc0/include/<a class="el" href="fuse-3_817_81-rc0_2include_2fuse_8h_source.html">fuse.h</a></li>
<li>include/<a class="el" href="include_2fuse_8h_source.html">fuse.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
