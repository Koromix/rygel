<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libfuse: fuse_lowlevel_ops Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libfuse
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle"><div class="title">fuse_lowlevel_ops Struct Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:aa8ed20e1d06c42a386404fba0d3e56b5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#aa8ed20e1d06c42a386404fba0d3e56b5">init</a> )(void *userdata, struct <a class="el" href="structfuse__conn__info.html">fuse_conn_info</a> *conn)</td></tr>
<tr class="separator:aa8ed20e1d06c42a386404fba0d3e56b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4eb554489467eaafa152d102cdac97d"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#ab4eb554489467eaafa152d102cdac97d">destroy</a> )(void *userdata)</td></tr>
<tr class="separator:ab4eb554489467eaafa152d102cdac97d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f46abd7c2795cfcf7a3d8c5ee8f6c70"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a7f46abd7c2795cfcf7a3d8c5ee8f6c70">lookup</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name)</td></tr>
<tr class="separator:a7f46abd7c2795cfcf7a3d8c5ee8f6c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fca05bcb3594ccd68d288ebd37a8467"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a9fca05bcb3594ccd68d288ebd37a8467">forget</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, uint64_t nlookup)</td></tr>
<tr class="separator:a9fca05bcb3594ccd68d288ebd37a8467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863ccafbcdd07a55835c4e82c4854155"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a863ccafbcdd07a55835c4e82c4854155">getattr</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a863ccafbcdd07a55835c4e82c4854155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fce08ae0d6a4f289bffbf9a9defe926"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a8fce08ae0d6a4f289bffbf9a9defe926">setattr</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct stat *attr, int to_set, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a8fce08ae0d6a4f289bffbf9a9defe926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc02a9a897f917f69295c011bebc6fd1"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#adc02a9a897f917f69295c011bebc6fd1">readlink</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino)</td></tr>
<tr class="separator:adc02a9a897f917f69295c011bebc6fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4bdf5bac31f832125c76ee3b8e055f8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#ad4bdf5bac31f832125c76ee3b8e055f8">mknod</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name, mode_t mode, dev_t rdev)</td></tr>
<tr class="separator:ad4bdf5bac31f832125c76ee3b8e055f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6304d15b02fe536646d6671784169eb"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#ab6304d15b02fe536646d6671784169eb">mkdir</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name, mode_t mode)</td></tr>
<tr class="separator:ab6304d15b02fe536646d6671784169eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1661bb4e3a4e689ff479fdd83b59deff"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a1661bb4e3a4e689ff479fdd83b59deff">unlink</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name)</td></tr>
<tr class="separator:a1661bb4e3a4e689ff479fdd83b59deff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa713229657659b76e6ecf2e8515e2219"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#aa713229657659b76e6ecf2e8515e2219">rmdir</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name)</td></tr>
<tr class="separator:aa713229657659b76e6ecf2e8515e2219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f37006d0cd3fb33dd96cb1b11087e17"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a3f37006d0cd3fb33dd96cb1b11087e17">symlink</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, const char *<a class="el" href="structfuse__lowlevel__ops.html#a771fc9da703b4c6544954844684914fd">link</a>, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name)</td></tr>
<tr class="separator:a3f37006d0cd3fb33dd96cb1b11087e17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177134df979e38c73600636b05ddf7d8"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a177134df979e38c73600636b05ddf7d8">rename</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> newparent, const char *newname, unsigned int flags)</td></tr>
<tr class="separator:a177134df979e38c73600636b05ddf7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a771fc9da703b4c6544954844684914fd"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a771fc9da703b4c6544954844684914fd">link</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> newparent, const char *newname)</td></tr>
<tr class="separator:a771fc9da703b4c6544954844684914fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9407639babe9be1523009820a09a3628"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a9407639babe9be1523009820a09a3628">open</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a9407639babe9be1523009820a09a3628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd81057f639eec4b08927fc4c95dd41"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#addd81057f639eec4b08927fc4c95dd41">read</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:addd81057f639eec4b08927fc4c95dd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79487b4a8480b105b4e5125434806808"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a79487b4a8480b105b4e5125434806808">write</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, const char *buf, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a79487b4a8480b105b4e5125434806808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae69315421ba606590fed75353ec5d7ff"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#ae69315421ba606590fed75353ec5d7ff">flush</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:ae69315421ba606590fed75353ec5d7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b606c5500d84572f3daa39e6178fe64"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a5b606c5500d84572f3daa39e6178fe64">release</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a5b606c5500d84572f3daa39e6178fe64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cc8076319d4784ed316b433840b81d"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a11cc8076319d4784ed316b433840b81d">fsync</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, int datasync, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a11cc8076319d4784ed316b433840b81d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa15612c68f7971cadfe3d3ec0a8b70e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#afa15612c68f7971cadfe3d3ec0a8b70e">opendir</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:afa15612c68f7971cadfe3d3ec0a8b70e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b7d7fc14d3958d7fb7d215fda20301"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a65b7d7fc14d3958d7fb7d215fda20301">readdir</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a65b7d7fc14d3958d7fb7d215fda20301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300ad176ae0d87ab97bd1783e05e4841"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a300ad176ae0d87ab97bd1783e05e4841">releasedir</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a300ad176ae0d87ab97bd1783e05e4841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4cf3177aa816446553363dbb51e696d"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#ab4cf3177aa816446553363dbb51e696d">fsyncdir</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, int datasync, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:ab4cf3177aa816446553363dbb51e696d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49f448bb238f0b490af7980a0af1e486"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a49f448bb238f0b490af7980a0af1e486">statfs</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino)</td></tr>
<tr class="separator:a49f448bb238f0b490af7980a0af1e486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f085ab232e7beeb7f83e458103afad"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a31f085ab232e7beeb7f83e458103afad">setxattr</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, const char *name, const char *value, size_t size, int flags)</td></tr>
<tr class="separator:a31f085ab232e7beeb7f83e458103afad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17214333ecd23875c07cbbfc072ce322"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a17214333ecd23875c07cbbfc072ce322">getxattr</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, const char *name, size_t size)</td></tr>
<tr class="separator:a17214333ecd23875c07cbbfc072ce322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af181f938a15cc314775173ef4744c0b1"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#af181f938a15cc314775173ef4744c0b1">listxattr</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, size_t size)</td></tr>
<tr class="separator:af181f938a15cc314775173ef4744c0b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94ea8297d13b020f7129c362f92fb0e5"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a94ea8297d13b020f7129c362f92fb0e5">removexattr</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, const char *name)</td></tr>
<tr class="separator:a94ea8297d13b020f7129c362f92fb0e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9fec3156389a36345dbbb76161641c7"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#ac9fec3156389a36345dbbb76161641c7">access</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, int mask)</td></tr>
<tr class="separator:ac9fec3156389a36345dbbb76161641c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5462b231d9e4af6e3b7dd288992603"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a6d5462b231d9e4af6e3b7dd288992603">create</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name, mode_t mode, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a6d5462b231d9e4af6e3b7dd288992603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5cdd0ad2881d6893671ff8d7929afea"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#ad5cdd0ad2881d6893671ff8d7929afea">getlk</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, struct <a class="el" href="structfuse__lowlevel__ops.html#a840ce0b71db19ed4607fe444d2d4c14e">flock</a> *lock)</td></tr>
<tr class="separator:ad5cdd0ad2881d6893671ff8d7929afea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5d0b2dd7f3ba02c5cd514a470fbd35"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#aaa5d0b2dd7f3ba02c5cd514a470fbd35">setlk</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, struct <a class="el" href="structfuse__lowlevel__ops.html#a840ce0b71db19ed4607fe444d2d4c14e">flock</a> *lock, int sleep)</td></tr>
<tr class="separator:aaa5d0b2dd7f3ba02c5cd514a470fbd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1494daeb570415261a157e714b6875f2"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a1494daeb570415261a157e714b6875f2">bmap</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, size_t blocksize, uint64_t idx)</td></tr>
<tr class="separator:a1494daeb570415261a157e714b6875f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3b213948a593cc85bb0e51cf05004c3"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#aa3b213948a593cc85bb0e51cf05004c3">ioctl</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, unsigned int cmd, void *arg, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, unsigned flags, const void *in_buf, size_t in_bufsz, size_t out_bufsz)</td></tr>
<tr class="separator:aa3b213948a593cc85bb0e51cf05004c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa018e55c9f36451cdeabcd1e044b3015"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#aa018e55c9f36451cdeabcd1e044b3015">poll</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, struct fuse_pollhandle *ph)</td></tr>
<tr class="separator:aa018e55c9f36451cdeabcd1e044b3015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a367c8976fafade9584f65f04592b6980"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a367c8976fafade9584f65f04592b6980">write_buf</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *bufv, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a367c8976fafade9584f65f04592b6980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabcc4e0721c891ec31b5e18185fe83c7"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#aabcc4e0721c891ec31b5e18185fe83c7">retrieve_reply</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, void *cookie, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, off_t offset, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *bufv)</td></tr>
<tr class="separator:aabcc4e0721c891ec31b5e18185fe83c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccc9bbfa0b3d4f8d5f8d4522b7f68f1"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#afccc9bbfa0b3d4f8d5f8d4522b7f68f1">forget_multi</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, size_t count, struct fuse_forget_data *forgets)</td></tr>
<tr class="separator:afccc9bbfa0b3d4f8d5f8d4522b7f68f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840ce0b71db19ed4607fe444d2d4c14e"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a840ce0b71db19ed4607fe444d2d4c14e">flock</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, int op)</td></tr>
<tr class="separator:a840ce0b71db19ed4607fe444d2d4c14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66727384614c3fa8d44b4ad1fc9da36b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a66727384614c3fa8d44b4ad1fc9da36b">fallocate</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, int mode, off_t offset, off_t length, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a66727384614c3fa8d44b4ad1fc9da36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c19a8b50f0520d3857cf0af4c9b1a7"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a83c19a8b50f0520d3857cf0af4c9b1a7">readdirplus</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:a83c19a8b50f0520d3857cf0af4c9b1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871740861ba7ea9d3198cc6b81485b4b"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#a871740861ba7ea9d3198cc6b81485b4b">copy_file_range</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino_in, off_t off_in, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi_in, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino_out, off_t off_out, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi_out, size_t len, int flags)</td></tr>
<tr class="separator:a871740861ba7ea9d3198cc6b81485b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51ee6da03a2bca6ee18e0be59303ed2"><td class="memItemLeft" align="right" valign="top">void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfuse__lowlevel__ops.html#ad51ee6da03a2bca6ee18e0be59303ed2">lseek</a> )(<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, off_t off, int whence, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td></tr>
<tr class="separator:ad51ee6da03a2bca6ee18e0be59303ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Low level filesystem operations</p>
<p >Most of the methods (with the exception of init and destroy) receive a request handle (fuse_req_t) as their first argument. This handle must be passed to one of the specified reply functions.</p>
<p >This may be done inside the method invocation, or after the call has returned. The request handle is valid until one of the reply functions is called.</p>
<p >Other pointer arguments (name, <a class="el" href="structfuse__file__info.html">fuse_file_info</a>, etc) are not valid after the call has returned, so if they are needed later, their contents have to be copied.</p>
<p >In general, all methods are expected to perform any necessary permission checking. However, a filesystem may delegate this task to the kernel by passing the <code>default_permissions</code> mount option to <code><a class="el" href="fuse__lowlevel_8h.html#a7b2ad9a131330718f9677878cf2ce89f">fuse_session_new()</a></code>. In this case, methods will only be called if the kernel's permission check has succeeded.</p>
<p >The filesystem sometimes needs to handle a return value of -ENOENT from the reply function, which means, that the request was interrupted, and the reply discarded. For example if <a class="el" href="fuse__lowlevel_8h.html#a170f8c6b953d70928e83bcecee43bfdc">fuse_reply_open()</a> return -ENOENT means, that the release method for this file will not be called. </p>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00201">201</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>
</div><h2 class="groupheader">Field Documentation</h2>
<a id="ac9fec3156389a36345dbbb76161641c7" name="ac9fec3156389a36345dbbb76161641c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9fec3156389a36345dbbb76161641c7">&#9670;&nbsp;</a></span>access</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::access) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, int mask)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check file access permissions</p>
<p >This will be called for the <a class="el" href="structfuse__lowlevel__ops.html#ac9fec3156389a36345dbbb76161641c7">access()</a> and chdir() system calls. If the 'default_permissions' mount option is given, this method is not called.</p>
<p >This method is not called under Linux kernel versions 2.4.x</p>
<p >If this request is answered with an error code of ENOSYS, this is treated as a permanent success, i.e. this and all future <a class="el" href="structfuse__lowlevel__ops.html#ac9fec3156389a36345dbbb76161641c7">access()</a> requests will succeed without being send to the filesystem process.</p>
<p >Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">mask</td><td>requested access mode </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00932">932</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a1494daeb570415261a157e714b6875f2" name="a1494daeb570415261a157e714b6875f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1494daeb570415261a157e714b6875f2">&#9670;&nbsp;</a></span>bmap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::bmap) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, size_t blocksize, uint64_t idx)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Map block index within file to block index within device</p>
<p >Note: This makes sense only for block device backed filesystems mounted with the 'blkdev' option</p>
<p >If this request is answered with an error code of ENOSYS, this is treated as a permanent failure, i.e. all future <a class="el" href="structfuse__lowlevel__ops.html#a1494daeb570415261a157e714b6875f2">bmap()</a> requests will fail with the same error code without being send to the filesystem process.</p>
<p >Valid replies: fuse_reply_bmap fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">blocksize</td><td>unit of block index </td></tr>
    <tr><td class="paramname">idx</td><td>block index within file </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l01025">1025</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a871740861ba7ea9d3198cc6b81485b4b" name="a871740861ba7ea9d3198cc6b81485b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871740861ba7ea9d3198cc6b81485b4b">&#9670;&nbsp;</a></span>copy_file_range</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::copy_file_range) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino_in, off_t off_in, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi_in, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino_out, off_t off_out, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi_out, size_t len, int flags)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Copy a range of data from one file to another</p>
<p >Performs an optimized copy between two file descriptors without the additional cost of transferring data through the FUSE kernel module to user space (glibc) and then back into the FUSE filesystem again.</p>
<p >In case this method is not implemented, glibc falls back to reading data from the source and writing to the destination. Effectively doing an inefficient copy of the data.</p>
<p >If this request is answered with an error code of ENOSYS, this is treated as a permanent failure with error code EOPNOTSUPP, i.e. all future <a class="el" href="structfuse__lowlevel__ops.html#a871740861ba7ea9d3198cc6b81485b4b">copy_file_range()</a> requests will fail with EOPNOTSUPP without being send to the filesystem process.</p>
<p >Valid replies: fuse_reply_write fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino_in</td><td>the inode number or the source file </td></tr>
    <tr><td class="paramname">off_in</td><td>starting point from were the data should be read </td></tr>
    <tr><td class="paramname">fi_in</td><td>file information of the source file </td></tr>
    <tr><td class="paramname">ino_out</td><td>the inode number or the destination file </td></tr>
    <tr><td class="paramname">off_out</td><td>starting point where the data should be written </td></tr>
    <tr><td class="paramname">fi_out</td><td>file information of the destination file </td></tr>
    <tr><td class="paramname">len</td><td>maximum size of the data to copy </td></tr>
    <tr><td class="paramname">flags</td><td>passed along with the <a class="el" href="structfuse__lowlevel__ops.html#a871740861ba7ea9d3198cc6b81485b4b">copy_file_range()</a> syscall </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l01257">1257</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a6d5462b231d9e4af6e3b7dd288992603" name="a6d5462b231d9e4af6e3b7dd288992603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5462b231d9e4af6e3b7dd288992603">&#9670;&nbsp;</a></span>create</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::create) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name, mode_t mode, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create and open a file</p>
<p >If the file does not exist, first create it with the specified mode, and then open it.</p>
<p >See the description of the open handler for more information.</p>
<p >If this method is not implemented or under Linux kernel versions earlier than 2.6.15, the <a class="el" href="structfuse__lowlevel__ops.html#ad4bdf5bac31f832125c76ee3b8e055f8">mknod()</a> and <a class="el" href="structfuse__lowlevel__ops.html#a9407639babe9be1523009820a09a3628">open()</a> methods will be called instead.</p>
<p >If this request is answered with an error code of ENOSYS, the handler is treated as not implemented (i.e., for this and future requests the <a class="el" href="structfuse__lowlevel__ops.html#ad4bdf5bac31f832125c76ee3b8e055f8">mknod()</a> and <a class="el" href="structfuse__lowlevel__ops.html#a9407639babe9be1523009820a09a3628">open()</a> handlers will be called instead).</p>
<p >Valid replies: fuse_reply_create fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the parent directory </td></tr>
    <tr><td class="paramname">name</td><td>to create </td></tr>
    <tr><td class="paramname">mode</td><td>file type and mode with which to create the new file </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00961">961</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="ab4eb554489467eaafa152d102cdac97d" name="ab4eb554489467eaafa152d102cdac97d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4eb554489467eaafa152d102cdac97d">&#9670;&nbsp;</a></span>destroy</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::destroy) (void *userdata)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Clean up filesystem.</p>
<p >Called on filesystem exit. When this method is called, the connection to the kernel may be gone already, so that eg. calls to fuse_lowlevel_notify_* will fail.</p>
<p >There's no reply to this function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userdata</td><td>the user data passed to <a class="el" href="fuse__lowlevel_8h.html#a7b2ad9a131330718f9677878cf2ce89f">fuse_session_new()</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00231">231</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a66727384614c3fa8d44b4ad1fc9da36b" name="a66727384614c3fa8d44b4ad1fc9da36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66727384614c3fa8d44b4ad1fc9da36b">&#9670;&nbsp;</a></span>fallocate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::fallocate) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, int mode, off_t offset, off_t length, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Allocate requested space. If this function returns success then subsequent writes to the specified range shall not fail due to the lack of free space on the file system storage media.</p>
<p >If this request is answered with an error code of ENOSYS, this is treated as a permanent failure with error code EOPNOTSUPP, i.e. all future <a class="el" href="structfuse__lowlevel__ops.html#a66727384614c3fa8d44b4ad1fc9da36b">fallocate()</a> requests will fail with EOPNOTSUPP without being send to the filesystem process.</p>
<p >Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">offset</td><td>starting point for allocated region </td></tr>
    <tr><td class="paramname">length</td><td>size of allocated region </td></tr>
    <tr><td class="paramname">mode</td><td>determines the operation to be performed on the given range, see fallocate(2) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l01196">1196</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a840ce0b71db19ed4607fe444d2d4c14e" name="a840ce0b71db19ed4607fe444d2d4c14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840ce0b71db19ed4607fe444d2d4c14e">&#9670;&nbsp;</a></span>flock</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::flock) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, int op)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Acquire, modify or release a BSD file lock</p>
<p >Note: if the locking methods are not implemented, the kernel will still allow file locking to work locally. Hence these are only interesting for network filesystems and similar.</p>
<p >Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
    <tr><td class="paramname">op</td><td>the locking operation, see flock(2) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l01173">1173</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="ae69315421ba606590fed75353ec5d7ff" name="ae69315421ba606590fed75353ec5d7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae69315421ba606590fed75353ec5d7ff">&#9670;&nbsp;</a></span>flush</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::flush) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Flush method</p>
<p >This is called on each close() of the opened file.</p>
<p >Since file descriptors can be duplicated (dup, dup2, fork), for one open call there may be many flush calls.</p>
<p >Filesystems shouldn't assume that flush will always be called after some writes, or that if will be called at all.</p>
<p >fi-&gt;fh will contain the value set by the open method, or will be undefined if the open method didn't set any value.</p>
<p >NOTE: the name of the method is misleading, since (unlike fsync) the filesystem is not forced to flush pending writes. One reason to flush data is if the filesystem wants to return write errors during close. However, such use is non-portable because POSIX does not require <a href="http://pubs.opengroup.org/onlinepubs/9699919799/functions/close.html">close</a> to wait for delayed I/O to complete.</p>
<p >If the filesystem supports file locking operations (setlk, getlk) it should remove all locks belonging to 'fi-&gt;owner'.</p>
<p >If this request is answered with an error code of ENOSYS, this is treated as success and future calls to <a class="el" href="structfuse__lowlevel__ops.html#ae69315421ba606590fed75353ec5d7ff">flush()</a> will succeed automatically without being send to the filesystem process.</p>
<p >Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00640">640</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a9fca05bcb3594ccd68d288ebd37a8467" name="a9fca05bcb3594ccd68d288ebd37a8467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fca05bcb3594ccd68d288ebd37a8467">&#9670;&nbsp;</a></span>forget</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::forget) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, uint64_t nlookup)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Forget about an inode</p>
<p >This function is called when the kernel removes an inode from its internal caches.</p>
<p >The inode's lookup count increases by one for every call to fuse_reply_entry and fuse_reply_create. The nlookup parameter indicates by how much the lookup count should be decreased.</p>
<p >Inodes with a non-zero lookup count may receive request from the kernel even after calls to unlink, rmdir or (when overwriting an existing file) rename. Filesystems must handle such requests properly and it is recommended to defer removal of the inode until the lookup count reaches zero. Calls to unlink, rmdir or rename will be followed closely by forget unless the file or directory is open, in which case the kernel issues forget only after the release or releasedir calls.</p>
<p >Note that if a file system will be exported over NFS the inodes lifetime must extend even beyond forget. See the generation field in struct <a class="el" href="structfuse__entry__param.html">fuse_entry_param</a> above.</p>
<p >On unmount the lookup count for all inodes implicitly drops to zero. It is not guaranteed that the file system will receive corresponding forget messages for the affected inodes.</p>
<p >Valid replies: fuse_reply_none</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">nlookup</td><td>the number of lookups to forget </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00282">282</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="afccc9bbfa0b3d4f8d5f8d4522b7f68f1" name="afccc9bbfa0b3d4f8d5f8d4522b7f68f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccc9bbfa0b3d4f8d5f8d4522b7f68f1">&#9670;&nbsp;</a></span>forget_multi</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::forget_multi) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, size_t count, struct fuse_forget_data *forgets)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Forget about multiple inodes</p>
<p >See description of the forget function for more information.</p>
<p >Valid replies: fuse_reply_none</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l01155">1155</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a11cc8076319d4784ed316b433840b81d" name="a11cc8076319d4784ed316b433840b81d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cc8076319d4784ed316b433840b81d">&#9670;&nbsp;</a></span>fsync</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::fsync) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, int datasync, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Synchronize file contents</p>
<p >If the datasync parameter is non-zero, then only the user data should be flushed, not the meta data.</p>
<p >If this request is answered with an error code of ENOSYS, this is treated as success and future calls to <a class="el" href="structfuse__lowlevel__ops.html#a11cc8076319d4784ed316b433840b81d">fsync()</a> will succeed automatically without being send to the filesystem process.</p>
<p >Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">datasync</td><td>flag indicating if only data should be flushed </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00690">690</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="ab4cf3177aa816446553363dbb51e696d" name="ab4cf3177aa816446553363dbb51e696d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4cf3177aa816446553363dbb51e696d">&#9670;&nbsp;</a></span>fsyncdir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::fsyncdir) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, int datasync, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Synchronize directory contents</p>
<p >If the datasync parameter is non-zero, then only the directory contents should be flushed, not the meta data.</p>
<p >fi-&gt;fh will contain the value set by the opendir method, or will be undefined if the opendir method didn't set any value.</p>
<p >If this request is answered with an error code of ENOSYS, this is treated as success and future calls to <a class="el" href="structfuse__lowlevel__ops.html#ab4cf3177aa816446553363dbb51e696d">fsyncdir()</a> will succeed automatically without being send to the filesystem process.</p>
<p >Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">datasync</td><td>flag indicating if only data should be flushed </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00805">805</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a863ccafbcdd07a55835c4e82c4854155" name="a863ccafbcdd07a55835c4e82c4854155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863ccafbcdd07a55835c4e82c4854155">&#9670;&nbsp;</a></span>getattr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::getattr) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get file attributes.</p>
<p >If writeback caching is enabled, the kernel may have a better idea of a file's length than the FUSE file system (eg if there has been a write that extended the file size, but that has not yet been passed to the filesystem.n</p>
<p >In this case, the st_size value provided by the file system will be ignored.</p>
<p >Valid replies: fuse_reply_attr fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>for future use, currently always NULL </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00303">303</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="ad5cdd0ad2881d6893671ff8d7929afea" name="ad5cdd0ad2881d6893671ff8d7929afea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5cdd0ad2881d6893671ff8d7929afea">&#9670;&nbsp;</a></span>getlk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::getlk) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, struct <a class="el" href="structfuse__lowlevel__ops.html#a840ce0b71db19ed4607fe444d2d4c14e">flock</a> *lock)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Test for a POSIX file lock</p>
<p >Valid replies: fuse_reply_lock fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
    <tr><td class="paramname">lock</td><td>the region/type to test </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00976">976</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a17214333ecd23875c07cbbfc072ce322" name="a17214333ecd23875c07cbbfc072ce322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17214333ecd23875c07cbbfc072ce322">&#9670;&nbsp;</a></span>getxattr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::getxattr) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, const char *name, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get an extended attribute</p>
<p >If size is zero, the size of the value should be sent with fuse_reply_xattr.</p>
<p >If the size is non-zero, and the value fits in the buffer, the value should be sent with fuse_reply_buf.</p>
<p >If the size is too small for the value, the ERANGE error should be sent.</p>
<p >If this request is answered with an error code of ENOSYS, this is treated as a permanent failure with error code EOPNOTSUPP, i.e. all future <a class="el" href="structfuse__lowlevel__ops.html#a17214333ecd23875c07cbbfc072ce322">getxattr()</a> requests will fail with EOPNOTSUPP without being send to the filesystem process.</p>
<p >Valid replies: fuse_reply_buf fuse_reply_data fuse_reply_xattr fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">name</td><td>of the extended attribute </td></tr>
    <tr><td class="paramname">size</td><td>maximum size of the value to send </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00862">862</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="aa8ed20e1d06c42a386404fba0d3e56b5" name="aa8ed20e1d06c42a386404fba0d3e56b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ed20e1d06c42a386404fba0d3e56b5">&#9670;&nbsp;</a></span>init</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::init) (void *userdata, struct <a class="el" href="structfuse__conn__info.html">fuse_conn_info</a> *conn)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialize filesystem</p>
<p >This function is called when libfuse establishes communication with the FUSE kernel module. The file system should use this module to inspect and/or modify the connection parameters provided in the <code>conn</code> structure.</p>
<p >Note that some parameters may be overwritten by options passed to <a class="el" href="fuse__lowlevel_8h.html#a7b2ad9a131330718f9677878cf2ce89f">fuse_session_new()</a> which take precedence over the values set in this handler.</p>
<p >There's no reply to this function</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">userdata</td><td>the user data passed to <a class="el" href="fuse__lowlevel_8h.html#a7b2ad9a131330718f9677878cf2ce89f">fuse_session_new()</a> </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00218">218</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="aa3b213948a593cc85bb0e51cf05004c3" name="aa3b213948a593cc85bb0e51cf05004c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3b213948a593cc85bb0e51cf05004c3">&#9670;&nbsp;</a></span>ioctl</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::ioctl) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, unsigned int cmd, void *arg, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, unsigned flags, const void *in_buf, size_t in_bufsz, size_t out_bufsz)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Ioctl</p>
<p >Note: For unrestricted ioctls (not allowed for FUSE servers), data in and out areas can be discovered by giving iovs and setting FUSE_IOCTL_RETRY in <em>flags</em>. For restricted ioctls, kernel prepares in/out data area according to the information encoded in cmd.</p>
<p >Valid replies: fuse_reply_ioctl_retry fuse_reply_ioctl fuse_reply_ioctl_iov fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">cmd</td><td>ioctl command </td></tr>
    <tr><td class="paramname">arg</td><td>ioctl argument </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
    <tr><td class="paramname">flags</td><td>for FUSE_IOCTL_* flags </td></tr>
    <tr><td class="paramname">in_buf</td><td>data fetched from the caller </td></tr>
    <tr><td class="paramname">in_bufsz</td><td>number of fetched bytes </td></tr>
    <tr><td class="paramname">out_bufsz</td><td>maximum size of output data</td></tr>
  </table>
  </dd>
</dl>
<p>Note : the unsigned long request submitted by the application is truncated to 32 bits. </p>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l01061">1061</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a771fc9da703b4c6544954844684914fd" name="a771fc9da703b4c6544954844684914fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a771fc9da703b4c6544954844684914fd">&#9670;&nbsp;</a></span>link</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::link) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> newparent, const char *newname)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a hard link</p>
<p >Valid replies: fuse_reply_entry fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the old inode number </td></tr>
    <tr><td class="paramname">newparent</td><td>inode number of the new parent directory </td></tr>
    <tr><td class="paramname">newname</td><td>new name to create </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00483">483</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="af181f938a15cc314775173ef4744c0b1" name="af181f938a15cc314775173ef4744c0b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af181f938a15cc314775173ef4744c0b1">&#9670;&nbsp;</a></span>listxattr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::listxattr) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, size_t size)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >List extended attribute names</p>
<p >If size is zero, the total size of the attribute list should be sent with fuse_reply_xattr.</p>
<p >If the size is non-zero, and the null character separated attribute list fits in the buffer, the list should be sent with fuse_reply_buf.</p>
<p >If the size is too small for the list, the ERANGE error should be sent.</p>
<p >If this request is answered with an error code of ENOSYS, this is treated as a permanent failure with error code EOPNOTSUPP, i.e. all future <a class="el" href="structfuse__lowlevel__ops.html#af181f938a15cc314775173ef4744c0b1">listxattr()</a> requests will fail with EOPNOTSUPP without being send to the filesystem process.</p>
<p >Valid replies: fuse_reply_buf fuse_reply_data fuse_reply_xattr fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">size</td><td>maximum size of the list to send </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00893">893</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a7f46abd7c2795cfcf7a3d8c5ee8f6c70" name="a7f46abd7c2795cfcf7a3d8c5ee8f6c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f46abd7c2795cfcf7a3d8c5ee8f6c70">&#9670;&nbsp;</a></span>lookup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::lookup) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Look up a directory entry by name and get its attributes.</p>
<p >Valid replies: fuse_reply_entry fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the parent directory </td></tr>
    <tr><td class="paramname">name</td><td>the name to look up </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00244">244</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="ad51ee6da03a2bca6ee18e0be59303ed2" name="ad51ee6da03a2bca6ee18e0be59303ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad51ee6da03a2bca6ee18e0be59303ed2">&#9670;&nbsp;</a></span>lseek</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::lseek) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, off_t off, int whence, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Find next data or hole after the specified offset</p>
<p >If this request is answered with an error code of ENOSYS, this is treated as a permanent failure, i.e. all future <a class="el" href="structfuse__lowlevel__ops.html#ad51ee6da03a2bca6ee18e0be59303ed2">lseek()</a> requests will fail with the same error code without being send to the filesystem process.</p>
<p >Valid replies: fuse_reply_lseek fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">off</td><td>offset to start search from </td></tr>
    <tr><td class="paramname">whence</td><td>either SEEK_DATA or SEEK_HOLE </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l01281">1281</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="ab6304d15b02fe536646d6671784169eb" name="ab6304d15b02fe536646d6671784169eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6304d15b02fe536646d6671784169eb">&#9670;&nbsp;</a></span>mkdir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::mkdir) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name, mode_t mode)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a directory</p>
<p >Valid replies: fuse_reply_entry fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the parent directory </td></tr>
    <tr><td class="paramname">name</td><td>to create </td></tr>
    <tr><td class="paramname">mode</td><td>with which to create the new file </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00386">386</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="ad4bdf5bac31f832125c76ee3b8e055f8" name="ad4bdf5bac31f832125c76ee3b8e055f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4bdf5bac31f832125c76ee3b8e055f8">&#9670;&nbsp;</a></span>mknod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::mknod) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name, mode_t mode, dev_t rdev)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create file node</p>
<p >Create a regular file, character device, block device, fifo or socket node.</p>
<p >Valid replies: fuse_reply_entry fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the parent directory </td></tr>
    <tr><td class="paramname">name</td><td>to create </td></tr>
    <tr><td class="paramname">mode</td><td>file type and mode with which to create the new file </td></tr>
    <tr><td class="paramname">rdev</td><td>the device number (only valid if created file is a device) </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00371">371</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a9407639babe9be1523009820a09a3628" name="a9407639babe9be1523009820a09a3628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9407639babe9be1523009820a09a3628">&#9670;&nbsp;</a></span>open</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::open) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Open a file</p>
<p >Open flags are available in fi-&gt;flags. The following rules apply.</p>
<ul>
<li>Creation (O_CREAT, O_EXCL, O_NOCTTY) flags will be filtered out / handled by the kernel.</li>
<li>Access modes (O_RDONLY, O_WRONLY, O_RDWR) should be used by the filesystem to check if the operation is permitted. If the <code>-o default_permissions</code> mount option is given, this check is already done by the kernel before calling <a class="el" href="structfuse__lowlevel__ops.html#a9407639babe9be1523009820a09a3628">open()</a> and may thus be omitted by the filesystem.</li>
<li>When writeback caching is enabled, the kernel may send read requests even for files opened with O_WRONLY. The filesystem should be prepared to handle this.</li>
<li>When writeback caching is disabled, the filesystem is expected to properly handle the O_APPEND flag and ensure that each write is appending to the end of the file.</li>
<li>When writeback caching is enabled, the kernel will handle O_APPEND. However, unless all changes to the file come through the kernel this will not work reliably. The filesystem should thus either ignore the O_APPEND flag (and let the kernel handle it), or return an error (indicating that reliably O_APPEND is not available).</li>
</ul>
<p >Filesystem may store an arbitrary file handle (pointer, index, etc) in fi-&gt;fh, and use this in other all other file operations (read, write, flush, release, fsync).</p>
<p >Filesystem may also implement stateless file I/O and not store anything in fi-&gt;fh.</p>
<p >There are also some flags (direct_io, keep_cache) which the filesystem may set in fi, to change the way the file is opened. See <a class="el" href="structfuse__file__info.html">fuse_file_info</a> structure in &lt;<a class="el" href="fuse__common_8h.html">fuse_common.h</a>&gt; for more details.</p>
<p >If this request is answered with an error code of ENOSYS and FUSE_CAP_NO_OPEN_SUPPORT is set in <code><a class="el" href="structfuse__conn__info.html#a8a1c61f5d7cc14249fb6971165bb958e">fuse_conn_info.capable</a></code>, this is treated as success and future calls to open and release will also succeed without being sent to the filesystem process.</p>
<p >Valid replies: fuse_reply_open fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00542">542</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="afa15612c68f7971cadfe3d3ec0a8b70e" name="afa15612c68f7971cadfe3d3ec0a8b70e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa15612c68f7971cadfe3d3ec0a8b70e">&#9670;&nbsp;</a></span>opendir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::opendir) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Open a directory</p>
<p >Filesystem may store an arbitrary file handle (pointer, index, etc) in fi-&gt;fh, and use this in other all other directory stream operations (readdir, releasedir, fsyncdir).</p>
<p >If this request is answered with an error code of ENOSYS and FUSE_CAP_NO_OPENDIR_SUPPORT is set in <code><a class="el" href="structfuse__conn__info.html#a8a1c61f5d7cc14249fb6971165bb958e">fuse_conn_info.capable</a></code>, this is treated as success and future calls to opendir and releasedir will also succeed without being sent to the filesystem process. In addition, the kernel will cache readdir results as if opendir returned FOPEN_KEEP_CACHE | FOPEN_CACHE_DIR.</p>
<p >Valid replies: fuse_reply_open fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00715">715</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="aa018e55c9f36451cdeabcd1e044b3015" name="aa018e55c9f36451cdeabcd1e044b3015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa018e55c9f36451cdeabcd1e044b3015">&#9670;&nbsp;</a></span>poll</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::poll) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, struct fuse_pollhandle *ph)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Poll for IO readiness</p>
<p >Note: If ph is non-NULL, the client should notify when IO readiness events occur by calling <a class="el" href="fuse__lowlevel_8h.html#ab078685b1f480188031fc40aa2e2fbca">fuse_lowlevel_notify_poll()</a> with the specified ph.</p>
<p >Regardless of the number of times poll with a non-NULL ph is received, single notification is enough to clear all. Notifying more times incurs overhead but doesn't harm correctness.</p>
<p >The callee is responsible for destroying ph with <a class="el" href="fuse__common_8h.html#adf5027f8a38b2efc03858efd7fdc756a">fuse_pollhandle_destroy()</a> when no longer in use.</p>
<p >If this request is answered with an error code of ENOSYS, this is treated as success (with a kernel-defined default poll-mask) and future calls to pull() will succeed the same way without being send to the filesystem process.</p>
<p >Valid replies: fuse_reply_poll fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
    <tr><td class="paramname">ph</td><td>poll handle to be used for notification </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l01095">1095</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="addd81057f639eec4b08927fc4c95dd41" name="addd81057f639eec4b08927fc4c95dd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd81057f639eec4b08927fc4c95dd41">&#9670;&nbsp;</a></span>read</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::read) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read data</p>
<p >Read should send exactly the number of bytes requested except on EOF or error, otherwise the rest of the data will be substituted with zeroes. An exception to this is when the file has been opened in 'direct_io' mode, in which case the return value of the read system call will reflect the return value of this operation.</p>
<p >fi-&gt;fh will contain the value set by the open method, or will be undefined if the open method didn't set any value.</p>
<p >Valid replies: fuse_reply_buf fuse_reply_iov fuse_reply_data fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">size</td><td>number of bytes to read </td></tr>
    <tr><td class="paramname">off</td><td>offset to read from </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00570">570</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a65b7d7fc14d3958d7fb7d215fda20301" name="a65b7d7fc14d3958d7fb7d215fda20301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65b7d7fc14d3958d7fb7d215fda20301">&#9670;&nbsp;</a></span>readdir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::readdir) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read directory</p>
<p >Send a buffer filled using <a class="el" href="fuse__lowlevel_8h.html#ad1957bcc8ece8c90f16c42c4daf3053f">fuse_add_direntry()</a>, with size not exceeding the requested size. Send an empty buffer on end of stream.</p>
<p >fi-&gt;fh will contain the value set by the opendir method, or will be undefined if the opendir method didn't set any value.</p>
<p >Returning a directory entry from <a class="el" href="structfuse__lowlevel__ops.html#a65b7d7fc14d3958d7fb7d215fda20301">readdir()</a> does not affect its lookup count.</p>
<p >If off_t is non-zero, then it will correspond to one of the off_t values that was previously returned by <a class="el" href="structfuse__lowlevel__ops.html#a65b7d7fc14d3958d7fb7d215fda20301">readdir()</a> for the same directory handle. In this case, <a class="el" href="structfuse__lowlevel__ops.html#a65b7d7fc14d3958d7fb7d215fda20301">readdir()</a> should skip over entries coming before the position defined by the off_t value. If entries are added or removed while the directory handle is open, the filesystem may still include the entries that have been removed, and may not report the entries that have been created. However, addition or removal of entries must never cause <a class="el" href="structfuse__lowlevel__ops.html#a65b7d7fc14d3958d7fb7d215fda20301">readdir()</a> to skip over unrelated entries or to report them more than once. This means that off_t can not be a simple index that enumerates the entries that have been returned but must contain sufficient information to uniquely determine the next directory entry to return even when the set of entries is changing.</p>
<p >The function does not have to report the '.' and '..' entries, but is allowed to do so. Note that, if readdir does not return '.' or '..', they will not be implicitly returned, and this behavior is observable by the caller.</p>
<p >Valid replies: fuse_reply_buf fuse_reply_data fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">size</td><td>maximum number of bytes to send </td></tr>
    <tr><td class="paramname">off</td><td>offset to continue reading the directory stream </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00761">761</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a83c19a8b50f0520d3857cf0af4c9b1a7" name="a83c19a8b50f0520d3857cf0af4c9b1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83c19a8b50f0520d3857cf0af4c9b1a7">&#9670;&nbsp;</a></span>readdirplus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::readdirplus) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read directory with attributes</p>
<p >Send a buffer filled using <a class="el" href="fuse__lowlevel_8h.html#a34f3f1beebacab5f717d95baf832a8a5">fuse_add_direntry_plus()</a>, with size not exceeding the requested size. Send an empty buffer on end of stream.</p>
<p >fi-&gt;fh will contain the value set by the opendir method, or will be undefined if the opendir method didn't set any value.</p>
<p >In contrast to <a class="el" href="structfuse__lowlevel__ops.html#a65b7d7fc14d3958d7fb7d215fda20301">readdir()</a> (which does not affect the lookup counts), the lookup count of every entry returned by <a class="el" href="structfuse__lowlevel__ops.html#a83c19a8b50f0520d3857cf0af4c9b1a7">readdirplus()</a>, except "." and "..", is incremented by one.</p>
<p >Valid replies: fuse_reply_buf fuse_reply_data fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">size</td><td>maximum number of bytes to send </td></tr>
    <tr><td class="paramname">off</td><td>offset to continue reading the directory stream </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l01224">1224</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="adc02a9a897f917f69295c011bebc6fd1" name="adc02a9a897f917f69295c011bebc6fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc02a9a897f917f69295c011bebc6fd1">&#9670;&nbsp;</a></span>readlink</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::readlink) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read symbolic link</p>
<p >Valid replies: fuse_reply_readlink fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00353">353</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a5b606c5500d84572f3daa39e6178fe64" name="a5b606c5500d84572f3daa39e6178fe64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b606c5500d84572f3daa39e6178fe64">&#9670;&nbsp;</a></span>release</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::release) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Release an open file</p>
<p >Release is called when there are no more references to an open file: all file descriptors are closed and all memory mappings are unmapped.</p>
<p >For every open call there will be exactly one release call (unless the filesystem is force-unmounted).</p>
<p >The filesystem may reply with an error, but error values are not returned to close() or munmap() which triggered the release.</p>
<p >fi-&gt;fh will contain the value set by the open method, or will be undefined if the open method didn't set any value. fi-&gt;flags will contain the same flags as for open.</p>
<p >Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00668">668</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a300ad176ae0d87ab97bd1783e05e4841" name="a300ad176ae0d87ab97bd1783e05e4841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300ad176ae0d87ab97bd1783e05e4841">&#9670;&nbsp;</a></span>releasedir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::releasedir) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Release an open directory</p>
<p >For every opendir call there will be exactly one releasedir call (unless the filesystem is force-unmounted).</p>
<p >fi-&gt;fh will contain the value set by the opendir method, or will be undefined if the opendir method didn't set any value.</p>
<p >Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00780">780</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a94ea8297d13b020f7129c362f92fb0e5" name="a94ea8297d13b020f7129c362f92fb0e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94ea8297d13b020f7129c362f92fb0e5">&#9670;&nbsp;</a></span>removexattr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::removexattr) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Remove an extended attribute</p>
<p >If this request is answered with an error code of ENOSYS, this is treated as a permanent failure with error code EOPNOTSUPP, i.e. all future <a class="el" href="structfuse__lowlevel__ops.html#a94ea8297d13b020f7129c362f92fb0e5">removexattr()</a> requests will fail with EOPNOTSUPP without being send to the filesystem process.</p>
<p >Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">name</td><td>of the extended attribute </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00910">910</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a177134df979e38c73600636b05ddf7d8" name="a177134df979e38c73600636b05ddf7d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177134df979e38c73600636b05ddf7d8">&#9670;&nbsp;</a></span>rename</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::rename) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> newparent, const char *newname, unsigned int flags)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Rename a file</p>
<p >If the target exists it should be atomically replaced. If the target's inode's lookup count is non-zero, the file system is expected to postpone any removal of the inode until the lookup count reaches zero (see description of the forget function).</p>
<p >If this request is answered with an error code of ENOSYS, this is treated as a permanent failure with error code EINVAL, i.e. all future bmap requests will fail with EINVAL without being send to the filesystem process.</p>
<p ><em>flags</em> may be <code>RENAME_EXCHANGE</code> or <code>RENAME_NOREPLACE</code>. If RENAME_NOREPLACE is specified, the filesystem must not overwrite <em>newname</em> if it exists and return an error instead. If <code>RENAME_EXCHANGE</code> is specified, the filesystem must atomically exchange the two files, i.e. both must exist and neither may be deleted.</p>
<p >Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the old parent directory </td></tr>
    <tr><td class="paramname">name</td><td>old name </td></tr>
    <tr><td class="paramname">newparent</td><td>inode number of the new parent directory </td></tr>
    <tr><td class="paramname">newname</td><td>new name </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00467">467</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="aabcc4e0721c891ec31b5e18185fe83c7" name="aabcc4e0721c891ec31b5e18185fe83c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabcc4e0721c891ec31b5e18185fe83c7">&#9670;&nbsp;</a></span>retrieve_reply</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::retrieve_reply) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, void *cookie, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, off_t offset, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *bufv)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Callback function for the retrieve request</p>
<p >Valid replies: fuse_reply_none</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">cookie</td><td>user data supplied to <a class="el" href="fuse__lowlevel_8h.html#a58cb3543209d2c29dc2830f2503b5058">fuse_lowlevel_notify_retrieve()</a> </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number supplied to <a class="el" href="fuse__lowlevel_8h.html#a58cb3543209d2c29dc2830f2503b5058">fuse_lowlevel_notify_retrieve()</a> </td></tr>
    <tr><td class="paramname">offset</td><td>the offset supplied to <a class="el" href="fuse__lowlevel_8h.html#a58cb3543209d2c29dc2830f2503b5058">fuse_lowlevel_notify_retrieve()</a> </td></tr>
    <tr><td class="paramname">bufv</td><td>the buffer containing the returned data </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l01141">1141</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="aa713229657659b76e6ecf2e8515e2219" name="aa713229657659b76e6ecf2e8515e2219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa713229657659b76e6ecf2e8515e2219">&#9670;&nbsp;</a></span>rmdir</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::rmdir) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Remove a directory</p>
<p >If the directory's inode's lookup count is non-zero, the file system is expected to postpone any removal of the inode until the lookup count reaches zero (see description of the forget function).</p>
<p >Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the parent directory </td></tr>
    <tr><td class="paramname">name</td><td>to remove </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00421">421</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a8fce08ae0d6a4f289bffbf9a9defe926" name="a8fce08ae0d6a4f289bffbf9a9defe926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fce08ae0d6a4f289bffbf9a9defe926">&#9670;&nbsp;</a></span>setattr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::setattr) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct stat *attr, int to_set, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set file attributes</p>
<p >In the 'attr' argument only members indicated by the 'to_set' bitmask contain valid values. Other members contain undefined values.</p>
<p >Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is expected to reset the setuid and setgid bits if the file size or owner is being changed.</p>
<p >This method will not be called to update st_atime or st_ctime implicitly (eg. after a <a class="el" href="structfuse__lowlevel__ops.html#addd81057f639eec4b08927fc4c95dd41">read()</a> request), and only be called to implicitly update st_mtime if writeback caching is active. It is the filesystem's responsibility to update these timestamps when needed, and (if desired) to implement mount options like <code>noatime</code> or <code>relatime</code>.</p>
<p >If the setattr was invoked from the ftruncate() system call under Linux kernel versions 2.6.15 or later, the fi-&gt;fh will contain the value set by the open method or will be undefined if the open method didn't set any value. Otherwise (not ftruncate call, or kernel version earlier than 2.6.15) the fi parameter will be NULL.</p>
<p >Valid replies: fuse_reply_attr fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">attr</td><td>the attributes </td></tr>
    <tr><td class="paramname">to_set</td><td>bit mask of attributes which should be set </td></tr>
    <tr><td class="paramname">fi</td><td>file information, or NULL </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00340">340</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="aaa5d0b2dd7f3ba02c5cd514a470fbd35" name="aaa5d0b2dd7f3ba02c5cd514a470fbd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa5d0b2dd7f3ba02c5cd514a470fbd35">&#9670;&nbsp;</a></span>setlk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::setlk) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi, struct <a class="el" href="structfuse__lowlevel__ops.html#a840ce0b71db19ed4607fe444d2d4c14e">flock</a> *lock, int sleep)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Acquire, modify or release a POSIX file lock</p>
<p >For POSIX threads (NPTL) there's a 1-1 relation between pid and owner, but otherwise this is not always the case. For checking lock ownership, 'fi-&gt;owner' must be used. The l_pid field in 'struct flock' should only be used to fill in this field in <a class="el" href="structfuse__lowlevel__ops.html#ad5cdd0ad2881d6893671ff8d7929afea">getlk()</a>.</p>
<p >Note: if the locking methods are not implemented, the kernel will still allow file locking to work locally. Hence these are only interesting for network filesystems and similar.</p>
<p >Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
    <tr><td class="paramname">lock</td><td>the region/type to set </td></tr>
    <tr><td class="paramname">sleep</td><td>locking operation may sleep </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l01001">1001</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a31f085ab232e7beeb7f83e458103afad" name="a31f085ab232e7beeb7f83e458103afad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f085ab232e7beeb7f83e458103afad">&#9670;&nbsp;</a></span>setxattr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::setxattr) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, const char *name, const char *value, size_t size, int flags)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Set an extended attribute</p>
<p >If this request is answered with an error code of ENOSYS, this is treated as a permanent failure with error code EOPNOTSUPP, i.e. all future <a class="el" href="structfuse__lowlevel__ops.html#a31f085ab232e7beeb7f83e458103afad">setxattr()</a> requests will fail with EOPNOTSUPP without being send to the filesystem process.</p>
<p >Valid replies: fuse_reply_err </p>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00831">831</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a49f448bb238f0b490af7980a0af1e486" name="a49f448bb238f0b490af7980a0af1e486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49f448bb238f0b490af7980a0af1e486">&#9670;&nbsp;</a></span>statfs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::statfs) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get file system statistics</p>
<p >Valid replies: fuse_reply_statfs fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number, zero means "undefined" </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00818">818</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a3f37006d0cd3fb33dd96cb1b11087e17" name="a3f37006d0cd3fb33dd96cb1b11087e17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f37006d0cd3fb33dd96cb1b11087e17">&#9670;&nbsp;</a></span>symlink</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::symlink) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, const char *<a class="el" href="structfuse__lowlevel__ops.html#a771fc9da703b4c6544954844684914fd">link</a>, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a symbolic link</p>
<p >Valid replies: fuse_reply_entry fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">link</td><td>the contents of the symbolic link </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the parent directory </td></tr>
    <tr><td class="paramname">name</td><td>to create </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00435">435</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a1661bb4e3a4e689ff479fdd83b59deff" name="a1661bb4e3a4e689ff479fdd83b59deff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1661bb4e3a4e689ff479fdd83b59deff">&#9670;&nbsp;</a></span>unlink</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::unlink) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> parent, const char *name)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Remove a file</p>
<p >If the file's inode's lookup count is non-zero, the file system is expected to postpone any removal of the inode until the lookup count reaches zero (see description of the forget function).</p>
<p >Valid replies: fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">parent</td><td>inode number of the parent directory </td></tr>
    <tr><td class="paramname">name</td><td>to remove </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00404">404</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a79487b4a8480b105b4e5125434806808" name="a79487b4a8480b105b4e5125434806808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79487b4a8480b105b4e5125434806808">&#9670;&nbsp;</a></span>write</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::write) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, const char *buf, size_t size, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write data</p>
<p >Write should return exactly the number of bytes requested except on error. An exception to this is when the file has been opened in 'direct_io' mode, in which case the return value of the write system call will reflect the return value of this operation.</p>
<p >Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is expected to reset the setuid and setgid bits.</p>
<p >fi-&gt;fh will contain the value set by the open method, or will be undefined if the open method didn't set any value.</p>
<p >Valid replies: fuse_reply_write fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">buf</td><td>data to write </td></tr>
    <tr><td class="paramname">size</td><td>number of bytes to write </td></tr>
    <tr><td class="paramname">off</td><td>offset to write to </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l00599">599</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<a id="a367c8976fafade9584f65f04592b6980" name="a367c8976fafade9584f65f04592b6980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a367c8976fafade9584f65f04592b6980">&#9670;&nbsp;</a></span>write_buf</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void(* fuse_lowlevel_ops::write_buf) (<a class="el" href="fuse__lowlevel_8h.html#a33e2aa4a8905a05397292ae047cd2257">fuse_req_t</a> req, <a class="el" href="fuse__lowlevel_8h.html#ad119a72f00b4cd2e4a500fd3364ae1e2">fuse_ino_t</a> ino, struct <a class="el" href="structfuse__bufvec.html">fuse_bufvec</a> *bufv, off_t off, struct <a class="el" href="structfuse__file__info.html">fuse_file_info</a> *fi)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write data made available in a buffer</p>
<p >This is a more generic version of the -&gt;<a class="el" href="structfuse__lowlevel__ops.html#a79487b4a8480b105b4e5125434806808">write()</a> method. If FUSE_CAP_SPLICE_READ is set in <a class="el" href="structfuse__conn__info.html#af45de81548b591f3004353a324e4e04d">fuse_conn_info.want</a> and the kernel supports splicing from the fuse device, then the data will be made available in pipe for supporting zero copy data transfer.</p>
<p >buf-&gt;count is guaranteed to be one (and thus buf-&gt;idx is always zero). The write_buf handler must ensure that bufv-&gt;off is correctly updated (reflecting the number of bytes read from bufv-&gt;buf[0]).</p>
<p >Unless FUSE_CAP_HANDLE_KILLPRIV is disabled, this method is expected to reset the setuid and setgid bits.</p>
<p >Valid replies: fuse_reply_write fuse_reply_err</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">req</td><td>request handle </td></tr>
    <tr><td class="paramname">ino</td><td>the inode number </td></tr>
    <tr><td class="paramname">bufv</td><td>buffer containing the data </td></tr>
    <tr><td class="paramname">off</td><td>offset to write to </td></tr>
    <tr><td class="paramname">fi</td><td>file information </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="fuse__lowlevel_8h_source.html#l01125">1125</a> of file <a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>include/<a class="el" href="fuse__lowlevel_8h_source.html">fuse_lowlevel.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
