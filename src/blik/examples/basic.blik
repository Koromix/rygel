# Ne cherchez pas la logique dans ce script, ce sont des bouts de code
# tapés presque au hasard pour mettrer au point le parseur.

let z = 5 + # Les nouvelles mettent fin à une commande, sauf si une expression est
        3   # encore ouverte comme c'est le cas ici avec le + non suivi d'une valeur.

let x = 2 + 8 * 5 - (0x1444 << 5) > 2 && true

# Les variables doivent être déclarées à l'aide du mot-clé let. Par défaut, leur valeur
# ne pas être modifiée par la suite à moins d'utiliser "let mut".

let test = (5 = 8)
let mut p = 8

# Les boucles for permettront à terme d'itérer sur différents objets, en attendant d'avoir
# des objets on peut déjà itérer sur des un intervalle d'entiers.

for i in 2...5
    for j in 3..6
        println("for loop ", i, " ", j)
    end
end

# Pour modifier la valeur d'une variable déjà créée il faut utiliser l'opérateur := (et non =)
# Je ne suis pas sûr pour ça, mais le but est d'éviter les erreurs dans les expressions,
# comme par exemple en JS ou en C quand on fait : if (a = 1) {}. C'est une source fréquente de
# bug, car au lieu de tester si a == 1 (ce qu'on voulait probablement faire), on assigne la
# valeur 1 à la variable a.

let mut i = 0
while i < 1000000
    i := i + 1
end
while i > 100 do i := i - 1
println("i = ", i)

p := 5
# test := true

# Les variables de ce langage ont une portée lexicale. En dehors de if, while & compagnie,
# il est possible de définir des blocs à l'aide de do/end. Les deux variables zzz et bleh
# dans le bloc ci-dessous n'existent plus à la sortie du bloc.

begin
    let zzz = 2
    let bleh = 8

    begin
    end

    begin
        let foobar = "STRING"
    end
end

# C'est un langage avec typage statique avec inférence de type. Si on ne précise par le
# type de variable il est déduit de l'expression à droite, mais on peut aussi le préciser.
# Si le type est précisé il est possible d'omettre la valeur d'initialisation.

let foo: String = "Hello" # OK
# let bar: Int = "World!" # This is an error and would not work if uncommented
let empty: Double

let mut txt = "FOO"
if test do txt := "BAR"
println(txt)

if empty < 1.0
    let blik = 2.0
    p := 227
else if true
    let blik = 3.0
    p := 89
else
    let blik = 4.0
    p := 226
end

println("The value of p is: ", p)

# Les fonctions sont également typées, bien évidemment ! On commence par fibonacci,
# un classique...

func fib(n: Int): Int
    if n <= 1 do return n
    return fib(n - 1) + fib(n - 2)
end

let fib_n = 13
println("fib(", fib_n, ") = ", fib(fib_n))

# On peut aussi faire des fonctions qui ne retournent pas de valeur ! En réalité
# elles retournent alors la valeur null (seule valeur possible du type Null).
# On remarque par ailleurs que les fonctions peuvent être appelés avant leur déclaration.

let nn: Null = test()
println(nn)

func test()
    for j in 0..8
    end
end

# Et maintenant une séquence assez random qui m'a servi à implémenter le support des fonctions :)

func tt(e: String, ii: Int): Bool
    let mut tte = 267
    begin
        let xx = 3
        tte := tte + xx * eee(xx + ii)
        eee(xx)
    end
    println("hello ", e, " (", ii, ") ", tte)
    return true
end

func eee(mut pp: Int): Int
    let xxxxx = 1
    println("CALLED eee with ", pp)
    pp := pp + 1
    return pp
end

let mut zz = 0
while zz < 3
    tt("Niels", zz)
    zz := zz + 1
end
while (zz := inc(zz)) < 9 do tt("Nelson", (zz := zz + 1) - 1)

func inc(pp: Int): Int do return pp + 1

func func0(): String
    return "func0()"
end
func inline0(): String do return "inline0()"

println("TESTING ", func0())
println("TESTING ", inline0())

# Les fonctions peuvent être surchargées

func overload() do println("test")
func overload(p1: Int) do println("test! (", p1, ")")
func overload(p1: Int,
              p2: Double) do println("test... (", p1, " -- ", p2, ")")

println("Test overloads!")
overload(2, 3.0)
overload(2)
overload()
# overload(2, 3, "hello") # Erreur car il n'y a pas de définition de overload() qui correspond
